{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"nxviz: Composable and rational network visualizations in matplotlib nxviz is a package for building rational network visualizations using matplotlib as a backend. Inspired heavily by the principles espoused in the grammar of graphics, nxviz provides ways to compose a graph visualization together by adhering to the following recipe: Prioritize node placement, mapping data to position and visual properties, Draw in edges, mapping data to visual properties, Add in annotations and highlights on the graph. nxviz is simultaneously a data visualization research project, art project, and declarative data visualization tool. We hope you enjoy using it to build beautiful graph visualizations. Installation Official Releases nxviz is available on PyPI: pip install nxviz It's also available on conda-forge: conda install -c conda-forge nxviz Pre-releases Pre-releases are done by installing directly from git: pip install git+https://github.com/ericmjl/nxviz.git Quickstart To make a Circos plot: # We assume you have a graph G that is a NetworkX graph object. # In this example, all nodes possess the \"group\" and \"value\" node attributes # where \"group\" is categorical and \"value\" is continuous, # and all edges have the \"edge_value\" node attribute as well. import nxviz as nv ax = nv . circos ( G , group_by = \"group\" , sort_by = \"value\" , node_color_by = \"group\" , edge_alpha_by = \"edge_value\" ) nv . annotate . circos_group ( G , group_by = \"group\" ) For more examples, including other plots that can be made, please see the examples gallery on the docs.","title":"Home"},{"location":"#nxviz-composable-and-rational-network-visualizations-in-matplotlib","text":"nxviz is a package for building rational network visualizations using matplotlib as a backend. Inspired heavily by the principles espoused in the grammar of graphics, nxviz provides ways to compose a graph visualization together by adhering to the following recipe: Prioritize node placement, mapping data to position and visual properties, Draw in edges, mapping data to visual properties, Add in annotations and highlights on the graph. nxviz is simultaneously a data visualization research project, art project, and declarative data visualization tool. We hope you enjoy using it to build beautiful graph visualizations.","title":"nxviz: Composable and rational network visualizations in matplotlib"},{"location":"#installation","text":"","title":"Installation"},{"location":"#official-releases","text":"nxviz is available on PyPI: pip install nxviz It's also available on conda-forge: conda install -c conda-forge nxviz","title":"Official Releases"},{"location":"#pre-releases","text":"Pre-releases are done by installing directly from git: pip install git+https://github.com/ericmjl/nxviz.git","title":"Pre-releases"},{"location":"#quickstart","text":"To make a Circos plot: # We assume you have a graph G that is a NetworkX graph object. # In this example, all nodes possess the \"group\" and \"value\" node attributes # where \"group\" is categorical and \"value\" is continuous, # and all edges have the \"edge_value\" node attribute as well. import nxviz as nv ax = nv . circos ( G , group_by = \"group\" , sort_by = \"value\" , node_color_by = \"group\" , edge_alpha_by = \"edge_value\" ) nv . annotate . circos_group ( G , group_by = \"group\" ) For more examples, including other plots that can be made, please see the examples gallery on the docs.","title":"Quickstart"},{"location":"contributors/","text":"Contributors Lead Developers Eric J. Ma (@ericmjl) Code Contributors Nora Kassner Christian Diener Thijs Hermans R. M. Keelan Downton Maximilian T. Strauss Brian Cajes (@bcajes) Ashutosh Chandra (@ashu16993) Rabeez Riaz <19100165 (at) lums.edu.pk> Erick Armingol Walter Hernandez Eduarda Centeno Alireza Hosseini Yashrajsinh Jadeja (@Yashrajsinh-Jadeja)","title":"Contributors"},{"location":"contributors/#contributors","text":"","title":"Contributors"},{"location":"contributors/#lead-developers","text":"Eric J. Ma (@ericmjl)","title":"Lead Developers"},{"location":"contributors/#code-contributors","text":"Nora Kassner Christian Diener Thijs Hermans R. M. Keelan Downton Maximilian T. Strauss Brian Cajes (@bcajes) Ashutosh Chandra (@ashu16993) Rabeez Riaz <19100165 (at) lums.edu.pk> Erick Armingol Walter Hernandez Eduarda Centeno Alireza Hosseini Yashrajsinh Jadeja (@Yashrajsinh-Jadeja)","title":"Code Contributors"},{"location":"history/","text":"Release History 0.7.0 (2021-XX-XX) Major refactor behind-the-scenes with a functional API. 0.3.7 (2018-XX-XX) Node labels in CircosPlot can now be rotated with the rotate_labels argument. 0.3.6 (2018-02-20) Implemented edge colours, thanks to @noragak. 0.3.5 (2018-01-20) Disabled health checks on certain tests. Added ability to configure plot size. Added docs on preparing a new release. Updated dependencies. 0.3.2 (2017-09-18) All plots except for HivePlot are implemented. Implemented auto-colorbar for plots that have continuous node colors. 0.1.0 (2016-07-15) First release on PyPI.","title":"Release History"},{"location":"history/#release-history","text":"","title":"Release History"},{"location":"history/#070-2021-xx-xx","text":"Major refactor behind-the-scenes with a functional API.","title":"0.7.0 (2021-XX-XX)"},{"location":"history/#037-2018-xx-xx","text":"Node labels in CircosPlot can now be rotated with the rotate_labels argument.","title":"0.3.7 (2018-XX-XX)"},{"location":"history/#036-2018-02-20","text":"Implemented edge colours, thanks to @noragak.","title":"0.3.6 (2018-02-20)"},{"location":"history/#035-2018-01-20","text":"Disabled health checks on certain tests. Added ability to configure plot size. Added docs on preparing a new release. Updated dependencies.","title":"0.3.5 (2018-01-20)"},{"location":"history/#032-2017-09-18","text":"All plots except for HivePlot are implemented. Implemented auto-colorbar for plots that have continuous node colors.","title":"0.3.2 (2017-09-18)"},{"location":"history/#010-2016-07-15","text":"First release on PyPI.","title":"0.1.0 (2016-07-15)"},{"location":"theory/","text":"How to think about network visualizations When you're asked to plot a network, is your first instinct to reach for the \"force-directed layout\"? If you try searching for the term on the internet, at first glance it sounds like not a bad idea. But once you try plotting anything with a significant number of nodes (one rule of thumb being 30 nodes or more), the visualization descends into a hairball mess. Ben Sneiderman once said, \"The purpose of visualization is insight, not picture.\" Hairballs, unfortunately, impede our ability to gain insight. Hairballs ultimately end up communicating that everything is connected to everything ... and that is highly uninformative. What we need is a structured way of building graph visualizations. Is there a way out of this mess? One answer to the question is yes, and nxviz is intended to be an implementation of network visualizations in Python that guides us network scientists towards thinking clearly about network visualizations. Just as a prism decomposes light into its constituent colours, an effective graph visualization will deconstruct a complex network into interesting structures. Our hope is that nxviz becomes that prism for you. Grammar of graph visualizations The key idea espoused in the Grammar of Graphics is that every element in a data visualization should be tied to data. Basically, nothing in a plot should be styled, shaped, or placed without data backing it. When we follow a grammar of graphics, we gain a framework to think about data visualization in general. In some senses, a grammar of graph visualizations is a subset of a grammar of graphics. What are the components of this grammar, or in other words, the rules by which we compose together a network visualization? Let's try to make sense of it. Prioritize node placement The first step out of hairball hell is to think clearly about where we want to place the nodes. Why? This is because nodes usually correspond to entities that sometimes can be grouped and sorted. For example, if a graph is constructed between people, then we may wish to group them by some categorical property (e.g. their hometown or school), and perhaps sort them by some quantitative or ordinal property (e.g. their age or time of entry into a venue). If exact spatial placement is not meaningful but relative spatial placement is, then we might choose to place the nodes along some line segment, such as a line, or a circle. Map node metadata to visual properties The node placement step brings us a major step out of hairball hell! Once we are done with node placement, we can go on to style the nodes in a data-driven fashion. If you read and re-read and study the Points of View column in Nature Methods, as well as most other data visualization guides, you'll see some patterns what visual properties of symbols are most easily connected to data. For quantitative data: Length and width are the easiest to map; Area is the next easiest scale on which to perceive scale; Transparency comes next, Colour is the last. In visualizing qualitative data, however, colour is an excellent first choice to begin with, provided you don't have too many categories to visualize (12 is a sane upper limit). In a graph visualization, the most obvious visual properties that we can control are: The size (area) of nodes, Their colour, And their transparency. Draw edges Once the nodes are drawn in, we next concern ourselves with how to draw edges. In most graph visualizations, edges are represented using using lines between the nodes. As such, we don't have to worry about the layout of edges; we only have to concern ourselves with the data-driven styling of the edges. The same principles apply above. How the lines are drawn may vary from plot type to plot type. For example, in a Hive plot, we may want to use Bezier curves to draw the lines, but in an Arc plot, we may want to use circular arcs instead. Meanwhile, in a Matrix plot, we might choose to use another shape to draw the edge rather than draw in a line. Either way, once we know the placement of the nodes, then we know how to draw in the relation between the two. Add in annotations Once the node layout, node styling, and edge styling are complete, we can add in annotations. For example, if there are groupings of nodes present, we can annotate the groups on the appropriate location. If there are colour mappings to quantitative values, then we might want to annotate the color bar on top. Add in highlights The final piece is to selectively add in highlights onto the plot. For example, we might wish to highlight a particular edge, or a particular group of edges. Or we might be interested in a particular node, and all of the edges that connect that node to other nodes. We might be concerned with in-edges only, or out-edges only, if we are dealing with a directed graph. Composability nxviz is designed with composability in mind. A pre-requisite of composability is that we are thinking clearly about what are independently-varying things that we can add up together. Shape and colour, for example, don't interfere with one another, and might be considered independent. Annotations can technically exist independent of node and edge drawing (though it might not be particularly meaningful); there's no deep-seated technical reason why we have to couple them together. Size and shape, by contrast, may get conflated with one another; for example, a square of side 4 units is going to be perceptually smaller than a circle of radius 4 units. The nxviz API is designed such that we can bring layout, styling, annotations and highlights in a composable fashion. Panels Once we know how to build a single graph visualization, we can extend the visualization through the principle of small multiples to highlight interesting patterns in the graph data that might be obscured looking at it in its totality. What are the ways in which we might want to slice our data? Because we are building discrete subplots using data, the data we are mapping to each subplot ideally should be categorical in nature. Here's a few examples where we might want to do this. (1) Hive plots Hive plots are designed to show two or three groups of nodes and their connections. They aren't designed to do more than three groups because of geometric constraints. That said, we can work around this constraint by extracting triplet subgroups of nodes, thus building a hive panel . (2) Focusing on edge categories We might wish to highlight different categories of edges if the edges have categorical metadata available. In each category, we select only a particular subset of edges to plot, while preserving the node set. In this way, we can get an arbitrary graph visualization panel by simply filtering different edges to visualize. (3) Focusing on node categories This works similarly to edge categories, except now, we filter the graph for certain categories of nodes. Here, because the node set changes, the edge set will also change. nxviz graph filtering API To support building panels, the nxviz graph filtering API (located in the nxviz.filter submodule) provides a few basic ways of filtering a graph. Filtering edges by a categorical attribute. Filtering nodes by a categorical attribute. Filtering edges (all, in-edges, or out-edges) attached to a particular category of nodes. Because the graph filtering step is usually the piece that is the most hasslesome to write, these are provided in the library.","title":"Principles of Visualization"},{"location":"theory/#how-to-think-about-network-visualizations","text":"When you're asked to plot a network, is your first instinct to reach for the \"force-directed layout\"? If you try searching for the term on the internet, at first glance it sounds like not a bad idea. But once you try plotting anything with a significant number of nodes (one rule of thumb being 30 nodes or more), the visualization descends into a hairball mess. Ben Sneiderman once said, \"The purpose of visualization is insight, not picture.\" Hairballs, unfortunately, impede our ability to gain insight. Hairballs ultimately end up communicating that everything is connected to everything ... and that is highly uninformative. What we need is a structured way of building graph visualizations. Is there a way out of this mess? One answer to the question is yes, and nxviz is intended to be an implementation of network visualizations in Python that guides us network scientists towards thinking clearly about network visualizations. Just as a prism decomposes light into its constituent colours, an effective graph visualization will deconstruct a complex network into interesting structures. Our hope is that nxviz becomes that prism for you.","title":"How to think about network visualizations"},{"location":"theory/#grammar-of-graph-visualizations","text":"The key idea espoused in the Grammar of Graphics is that every element in a data visualization should be tied to data. Basically, nothing in a plot should be styled, shaped, or placed without data backing it. When we follow a grammar of graphics, we gain a framework to think about data visualization in general. In some senses, a grammar of graph visualizations is a subset of a grammar of graphics. What are the components of this grammar, or in other words, the rules by which we compose together a network visualization? Let's try to make sense of it.","title":"Grammar of graph visualizations"},{"location":"theory/#prioritize-node-placement","text":"The first step out of hairball hell is to think clearly about where we want to place the nodes. Why? This is because nodes usually correspond to entities that sometimes can be grouped and sorted. For example, if a graph is constructed between people, then we may wish to group them by some categorical property (e.g. their hometown or school), and perhaps sort them by some quantitative or ordinal property (e.g. their age or time of entry into a venue). If exact spatial placement is not meaningful but relative spatial placement is, then we might choose to place the nodes along some line segment, such as a line, or a circle.","title":"Prioritize node placement"},{"location":"theory/#map-node-metadata-to-visual-properties","text":"The node placement step brings us a major step out of hairball hell! Once we are done with node placement, we can go on to style the nodes in a data-driven fashion. If you read and re-read and study the Points of View column in Nature Methods, as well as most other data visualization guides, you'll see some patterns what visual properties of symbols are most easily connected to data. For quantitative data: Length and width are the easiest to map; Area is the next easiest scale on which to perceive scale; Transparency comes next, Colour is the last. In visualizing qualitative data, however, colour is an excellent first choice to begin with, provided you don't have too many categories to visualize (12 is a sane upper limit). In a graph visualization, the most obvious visual properties that we can control are: The size (area) of nodes, Their colour, And their transparency.","title":"Map node metadata to visual properties"},{"location":"theory/#draw-edges","text":"Once the nodes are drawn in, we next concern ourselves with how to draw edges. In most graph visualizations, edges are represented using using lines between the nodes. As such, we don't have to worry about the layout of edges; we only have to concern ourselves with the data-driven styling of the edges. The same principles apply above. How the lines are drawn may vary from plot type to plot type. For example, in a Hive plot, we may want to use Bezier curves to draw the lines, but in an Arc plot, we may want to use circular arcs instead. Meanwhile, in a Matrix plot, we might choose to use another shape to draw the edge rather than draw in a line. Either way, once we know the placement of the nodes, then we know how to draw in the relation between the two.","title":"Draw edges"},{"location":"theory/#add-in-annotations","text":"Once the node layout, node styling, and edge styling are complete, we can add in annotations. For example, if there are groupings of nodes present, we can annotate the groups on the appropriate location. If there are colour mappings to quantitative values, then we might want to annotate the color bar on top.","title":"Add in annotations"},{"location":"theory/#add-in-highlights","text":"The final piece is to selectively add in highlights onto the plot. For example, we might wish to highlight a particular edge, or a particular group of edges. Or we might be interested in a particular node, and all of the edges that connect that node to other nodes. We might be concerned with in-edges only, or out-edges only, if we are dealing with a directed graph.","title":"Add in highlights"},{"location":"theory/#composability","text":"nxviz is designed with composability in mind. A pre-requisite of composability is that we are thinking clearly about what are independently-varying things that we can add up together. Shape and colour, for example, don't interfere with one another, and might be considered independent. Annotations can technically exist independent of node and edge drawing (though it might not be particularly meaningful); there's no deep-seated technical reason why we have to couple them together. Size and shape, by contrast, may get conflated with one another; for example, a square of side 4 units is going to be perceptually smaller than a circle of radius 4 units. The nxviz API is designed such that we can bring layout, styling, annotations and highlights in a composable fashion.","title":"Composability"},{"location":"theory/#panels","text":"Once we know how to build a single graph visualization, we can extend the visualization through the principle of small multiples to highlight interesting patterns in the graph data that might be obscured looking at it in its totality. What are the ways in which we might want to slice our data? Because we are building discrete subplots using data, the data we are mapping to each subplot ideally should be categorical in nature. Here's a few examples where we might want to do this. (1) Hive plots Hive plots are designed to show two or three groups of nodes and their connections. They aren't designed to do more than three groups because of geometric constraints. That said, we can work around this constraint by extracting triplet subgroups of nodes, thus building a hive panel . (2) Focusing on edge categories We might wish to highlight different categories of edges if the edges have categorical metadata available. In each category, we select only a particular subset of edges to plot, while preserving the node set. In this way, we can get an arbitrary graph visualization panel by simply filtering different edges to visualize. (3) Focusing on node categories This works similarly to edge categories, except now, we filter the graph for certain categories of nodes. Here, because the node set changes, the edge set will also change.","title":"Panels"},{"location":"theory/#nxviz-graph-filtering-api","text":"To support building panels, the nxviz graph filtering API (located in the nxviz.filter submodule) provides a few basic ways of filtering a graph. Filtering edges by a categorical attribute. Filtering nodes by a categorical attribute. Filtering edges (all, in-edges, or out-edges) attached to a particular category of nodes. Because the graph filtering step is usually the piece that is the most hasslesome to write, these are provided in the library.","title":"nxviz graph filtering API"},{"location":"api/facet-api/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Panels and Faceting In this notebook, we will introduce how to make graph visualization panels! % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 from random import choice import matplotlib.pyplot as plt import networkx as nx import numpy as np import nxviz as nv /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( Example graph Here's an example graph. It has both quantiative and qualitative data encoded on the nodes and edges. categories = \"abcdefghijk\" node_categories = \"12345\" G = nx . erdos_renyi_graph ( n = 70 , p = 0.1 ) for u , v in G . edges (): G . edges [ u , v ][ \"group\" ] = choice ( categories ) G . edges [ u , v ][ \"edge_val\" ] = np . random . exponential () for n in G . nodes (): G . nodes [ n ][ \"category\" ] = choice ( node_categories ) G . nodes [ n ][ \"value\" ] = np . random . normal () Non-panel'd version Let's see what happens if we just try to plot all nodes and all edges together. nv . circos ( G , group_by = \"category\" , node_color_by = \"category\" , edge_color_by = \"edge_val\" , edge_enc_kwargs = { \"alpha_scale\" : 5 }, ) <AxesSubplot:> This isn't particularly useful. The edges are over-populated on the visualization. If there were structure in the graph that were interesting, we'd find it hard to elucidate. Here, we can rely on the principle of small multiples to design a more effective visualizations. nxviz faceting API Graph visualization panels are the solution here. We use categorical metadata on nodes or edges to facet our visualizations. (Faceting refers to creating subplots that contain a subset of the full dataset, so that one can optimize for visual clarity.) Because nodes are more easily arranged than edges, we can facet our graph out by edge categories into panels . As such, one subcategory of graph visualization panels is defined by a faceting of our graph by edge categories. Here are some examples. from nxviz import annotate , facet # from nxviz import hive_panel, arc_panel, circos_panel from nxviz.utils import edge_table , node_table Arc Panel facet . arc_panel ( G , edge_group_by = \"group\" , node_group_by = \"category\" , node_color_by = \"category\" , edge_color_by = \"edge_val\" , ) Circos Panel facet . circos_panel ( G , edge_group_by = \"group\" , node_group_by = \"category\" , node_color_by = \"category\" , edge_color_by = \"edge_val\" , ) Matrix Panel facet . matrix_panel ( G , edge_group_by = \"group\" , node_group_by = \"category\" , node_color_by = \"category\" , edge_color_by = \"edge_val\" , ) Hive Panel Hive panels are a special type of panel. Because hive plots alone can plot either 2 or 3 categories of nodes, it can't handle situations where there are more than 3 categories of nodes. Here is where a panel of hive plots comes in: each plot in the panel handles 3 of the categories that are present. As such, you will have ${K}\\choose{3}$ plots to plot. For this reason, we don't recommend having more than 6 categories, otherwise you'll end up with a lot of plots to look at. facet . hive_panel ( G , node_group_by = \"category\" , node_color_by = \"category\" ) Custom panels While there are plot-specific faceting APIs, you can use the building blocks in there to compose your own. In this example, we'll show you how to create a facet where we show only edges that are associated with a particular group of nodes. For this, the key function to use is node_group_edges , which yields graphs that contains edges attached to a particular group, as well as the group itself. import inspect from nxviz.facet import n_rows_cols , node_group_edges print ( inspect . getsource ( node_group_edges )) def node_group_edges(G: nx.Graph, group_by: Hashable): \"\"\"Return a subgraph containing edges connected to a particular category of nodes.\"\"\" nt = utils.node_table(G) groups = sorted(nt[group_by].unique()) for group in groups: G_sub = G.copy() G_sub.remove_edges_from(G_sub.edges()) wanted_nodes = (n for n in G.nodes() if G.nodes[n][group_by] == group) for node in wanted_nodes: for u, v, d in G.edges(node, data=True): G_sub.add_edge(u, v, **d) yield G_sub, group node_group_by = \"category\" graphs , groups = zip ( * node_group_edges ( G , node_group_by )) nrows , ncols = n_rows_cols ( groups ) fig , axes = plt . subplots ( figsize = ( 8 , 8 ), nrows = 3 , ncols = 3 ) axes = list ( axes . flatten ()) for ax , G_sub , group in zip ( axes , graphs , groups ): plt . sca ( ax ) nv . circos ( G_sub , group_by = \"category\" , sort_by = \"value\" , node_color_by = \"category\" ) annotate . circos_group ( G_sub , group_by = \"category\" ) ax . set_title ( f \"node group = { group } \" ) i = axes . index ( ax ) for ax in axes [ i + 1 :]: fig . delaxes ( ax ) plt . tight_layout () Development pattern The core of faceting in nxviz is to return an iterator of graphs that contain either a subset of nodes, a subset of edges, or a subset of nodes and edges. Using one of the faceting functions as an example to illustrate: import inspect print ( inspect . getsource ( facet . edge_group )) def edge_group(G: nx.Graph, group_by: Hashable): \"\"\"Yield graphs containing only certain categories of edges.\"\"\" et = utils.edge_table(G) groups = sorted(et[group_by].unique()) for group in groups: G_sub = G.copy() G_sub.remove_edges_from(G_sub.edges()) for u, v, d in G.edges(data=True): if d[group_by] == group: G_sub.add_edge(u, v, **d) yield G_sub, group The pattern is essentially to identify the exact groups that exist, iterate over these groups, and yield a graph that contains any one of the aforementioned three subsets alongside the group. That function pattern makes faceting consistent.","title":"Faceting API"},{"location":"api/facet-api/#panels-and-faceting","text":"In this notebook, we will introduce how to make graph visualization panels! % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 from random import choice import matplotlib.pyplot as plt import networkx as nx import numpy as np import nxviz as nv /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn(","title":"Panels and Faceting"},{"location":"api/facet-api/#example-graph","text":"Here's an example graph. It has both quantiative and qualitative data encoded on the nodes and edges. categories = \"abcdefghijk\" node_categories = \"12345\" G = nx . erdos_renyi_graph ( n = 70 , p = 0.1 ) for u , v in G . edges (): G . edges [ u , v ][ \"group\" ] = choice ( categories ) G . edges [ u , v ][ \"edge_val\" ] = np . random . exponential () for n in G . nodes (): G . nodes [ n ][ \"category\" ] = choice ( node_categories ) G . nodes [ n ][ \"value\" ] = np . random . normal ()","title":"Example graph"},{"location":"api/facet-api/#non-paneld-version","text":"Let's see what happens if we just try to plot all nodes and all edges together. nv . circos ( G , group_by = \"category\" , node_color_by = \"category\" , edge_color_by = \"edge_val\" , edge_enc_kwargs = { \"alpha_scale\" : 5 }, ) <AxesSubplot:> This isn't particularly useful. The edges are over-populated on the visualization. If there were structure in the graph that were interesting, we'd find it hard to elucidate. Here, we can rely on the principle of small multiples to design a more effective visualizations.","title":"Non-panel'd version"},{"location":"api/facet-api/#nxviz-faceting-api","text":"Graph visualization panels are the solution here. We use categorical metadata on nodes or edges to facet our visualizations. (Faceting refers to creating subplots that contain a subset of the full dataset, so that one can optimize for visual clarity.) Because nodes are more easily arranged than edges, we can facet our graph out by edge categories into panels . As such, one subcategory of graph visualization panels is defined by a faceting of our graph by edge categories. Here are some examples. from nxviz import annotate , facet # from nxviz import hive_panel, arc_panel, circos_panel from nxviz.utils import edge_table , node_table","title":"nxviz faceting API"},{"location":"api/facet-api/#arc-panel","text":"facet . arc_panel ( G , edge_group_by = \"group\" , node_group_by = \"category\" , node_color_by = \"category\" , edge_color_by = \"edge_val\" , )","title":"Arc Panel"},{"location":"api/facet-api/#circos-panel","text":"facet . circos_panel ( G , edge_group_by = \"group\" , node_group_by = \"category\" , node_color_by = \"category\" , edge_color_by = \"edge_val\" , )","title":"Circos Panel"},{"location":"api/facet-api/#matrix-panel","text":"facet . matrix_panel ( G , edge_group_by = \"group\" , node_group_by = \"category\" , node_color_by = \"category\" , edge_color_by = \"edge_val\" , )","title":"Matrix Panel"},{"location":"api/facet-api/#hive-panel","text":"Hive panels are a special type of panel. Because hive plots alone can plot either 2 or 3 categories of nodes, it can't handle situations where there are more than 3 categories of nodes. Here is where a panel of hive plots comes in: each plot in the panel handles 3 of the categories that are present. As such, you will have ${K}\\choose{3}$ plots to plot. For this reason, we don't recommend having more than 6 categories, otherwise you'll end up with a lot of plots to look at. facet . hive_panel ( G , node_group_by = \"category\" , node_color_by = \"category\" )","title":"Hive Panel"},{"location":"api/facet-api/#custom-panels","text":"While there are plot-specific faceting APIs, you can use the building blocks in there to compose your own. In this example, we'll show you how to create a facet where we show only edges that are associated with a particular group of nodes. For this, the key function to use is node_group_edges , which yields graphs that contains edges attached to a particular group, as well as the group itself. import inspect from nxviz.facet import n_rows_cols , node_group_edges print ( inspect . getsource ( node_group_edges )) def node_group_edges(G: nx.Graph, group_by: Hashable): \"\"\"Return a subgraph containing edges connected to a particular category of nodes.\"\"\" nt = utils.node_table(G) groups = sorted(nt[group_by].unique()) for group in groups: G_sub = G.copy() G_sub.remove_edges_from(G_sub.edges()) wanted_nodes = (n for n in G.nodes() if G.nodes[n][group_by] == group) for node in wanted_nodes: for u, v, d in G.edges(node, data=True): G_sub.add_edge(u, v, **d) yield G_sub, group node_group_by = \"category\" graphs , groups = zip ( * node_group_edges ( G , node_group_by )) nrows , ncols = n_rows_cols ( groups ) fig , axes = plt . subplots ( figsize = ( 8 , 8 ), nrows = 3 , ncols = 3 ) axes = list ( axes . flatten ()) for ax , G_sub , group in zip ( axes , graphs , groups ): plt . sca ( ax ) nv . circos ( G_sub , group_by = \"category\" , sort_by = \"value\" , node_color_by = \"category\" ) annotate . circos_group ( G_sub , group_by = \"category\" ) ax . set_title ( f \"node group = { group } \" ) i = axes . index ( ax ) for ax in axes [ i + 1 :]: fig . delaxes ( ax ) plt . tight_layout ()","title":"Custom panels"},{"location":"api/facet-api/#development-pattern","text":"The core of faceting in nxviz is to return an iterator of graphs that contain either a subset of nodes, a subset of edges, or a subset of nodes and edges. Using one of the faceting functions as an example to illustrate: import inspect print ( inspect . getsource ( facet . edge_group )) def edge_group(G: nx.Graph, group_by: Hashable): \"\"\"Yield graphs containing only certain categories of edges.\"\"\" et = utils.edge_table(G) groups = sorted(et[group_by].unique()) for group in groups: G_sub = G.copy() G_sub.remove_edges_from(G_sub.edges()) for u, v, d in G.edges(data=True): if d[group_by] == group: G_sub.add_edge(u, v, **d) yield G_sub, group The pattern is essentially to identify the exact groups that exist, iterate over these groups, and yield a graph that contains any one of the aforementioned three subsets alongside the group. That function pattern makes faceting consistent.","title":"Development pattern"},{"location":"api/high-level-api/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); High Level API In this notebook, we will walk through the high level nxviz API. The intent here is to provide a convenient (albeit restrictive) way to build graph visualizations for exploratory analysis purposes. Our goal is to help you declaratively visualize a network using one of the rational visualizations provided. The design is intentionally quite restrictive; customizations are limited to what you can compose together. You should treat these the way you would use the plotting package seaborn : to get you a quick overview of your data without being bogged down by the details of how things are placed on the screen. If you want finer-grained control, then you may wish to drop down to the mid-level or low-level API instead. How to read this notebook Treat this notebook as a gallery of examples. As with all declarative APIs, it's important to know the structure of the graph. We're showing you the exact source code for graph construction, and the graph's corresponding node and edge tables, to make things easier to read. % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 from random import choice import matplotlib.pyplot as plt import networkx as nx import numpy as np import nxviz as nv from nxviz import annotate , highlights from nxviz.plots import despine , rescale , respine /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( Example Graph We're going to use an example graph, the erdos-renyi graph, to illustrate. Source code Here's the source code for graph generation. G = nx . erdos_renyi_graph ( n = 71 , p = 0.1 ) for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"group\" ] = choice ([ \"a\" , \"b\" , \"c\" ]) G . nodes [ n ][ \"value\" ] = np . random . exponential () np . random . seed ( 44 ) for u , v , d in G . edges ( data = True ): G . edges [ u , v ][ \"edge_value\" ] = np . random . exponential () from random import choice u , v = choice ( list ( G . edges ())) Node table from nxviz.utils import edge_table , node_table node_table ( G ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } group value 0 c 1.301247 1 a 0.127580 2 a 0.356859 3 c 0.792939 4 b 0.925250 ... ... ... 66 c 0.906692 67 b 0.095024 68 c 0.687436 69 c 0.366349 70 b 0.253142 71 rows \u00d7 2 columns edge_table ( G ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } edge_value source target 0 1.800854 0 23 1 1.800854 23 0 2 0.110704 0 28 3 0.110704 28 0 4 1.365083 0 35 ... ... ... ... 495 0.220343 68 67 496 1.806456 67 70 497 1.806456 70 67 498 0.557011 68 70 499 0.557011 70 68 500 rows \u00d7 3 columns Hive Plot Here's a Hive Plot view of the graph. The Hive plot is appropriate here, because we have one categorical variables with three values by which we can group our nodes. Here's one example where we group the nodes by their group attribute, sort and colour them by their value attribute, and set the transparency of an aged based on the edge's edge_value attribute. We also annotate the grouping on the hive plot. ax = nv . hive ( G , group_by = \"group\" , sort_by = \"value\" , node_color_by = \"value\" , edge_alpha_by = \"edge_value\" , ) annotate . hive_group ( G , group_by = \"group\" , offset = np . pi / 12 ) Here's an alternative visualization where we group and colour the nodes by their group attribute, ignoring the value attribute on the nodes and the edge_value attribute on the edges. ax = nv . hive ( G , group_by = \"group\" , node_color_by = \"group\" ) annotate . hive_group ( G , group_by = \"group\" ) highlights . hive_node ( G , u , group_by = \"group\" ) highlights . hive_node ( G , v , group_by = \"group\" ) highlights . hive_edge ( G , u , v , group_by = \"group\" ) The same consistent API applies to the other plot types. Arc Plot ax = nv . arc ( G , group_by = \"group\" , node_color_by = \"group\" , edge_alpha_by = \"edge_value\" ) annotate . arc_group ( G , group_by = \"group\" , ha = \"center\" , rotation = 0 ) highlights . arc_node ( G , u , group_by = \"group\" ) highlights . arc_node ( G , v , group_by = \"group\" ) highlights . arc_edge ( G , source = u , target = v , group_by = \"group\" ) Circos Plot ax = nv . circos ( G , group_by = \"group\" , node_color_by = \"group\" , edge_alpha_by = \"edge_value\" ) annotate . circos_group ( G , group_by = \"group\" ) highlights . circos_edge ( G , u , v , group_by = \"group\" ) highlights . circos_node ( G , u , group_by = \"group\" ) highlights . circos_node ( G , v , group_by = \"group\" , color = \"blue\" ) Matrix Plot fig , ax = plt . subplots ( figsize = ( 7 , 7 )) ax = nv . matrix ( G , group_by = \"group\" , sort_by = \"value\" , node_color_by = \"group\" , edge_alpha_by = \"edge_value\" , ) annotate . matrix_group ( G , group_by = \"group\" ) annotate . matrix_block ( G , group_by = \"group\" , color_by = \"group\" , alpha = 0.1 ) highlights . matrix_node ( G , u , group_by = \"group\" , sort_by = \"value\" ) highlights . matrix_node ( G , v , group_by = \"group\" , sort_by = \"value\" , color = \"blue\" ) highlights . matrix_row ( G , u , group_by = \"group\" , sort_by = \"value\" ) highlights . matrix_row ( G , v , group_by = \"group\" , sort_by = \"value\" , axis = \"y\" , color = \"blue\" ) highlights . matrix_edge ( G , u , v , group_by = \"group\" , sort_by = \"value\" )","title":"High level API"},{"location":"api/high-level-api/#high-level-api","text":"In this notebook, we will walk through the high level nxviz API. The intent here is to provide a convenient (albeit restrictive) way to build graph visualizations for exploratory analysis purposes. Our goal is to help you declaratively visualize a network using one of the rational visualizations provided. The design is intentionally quite restrictive; customizations are limited to what you can compose together. You should treat these the way you would use the plotting package seaborn : to get you a quick overview of your data without being bogged down by the details of how things are placed on the screen. If you want finer-grained control, then you may wish to drop down to the mid-level or low-level API instead.","title":"High Level API"},{"location":"api/high-level-api/#how-to-read-this-notebook","text":"Treat this notebook as a gallery of examples. As with all declarative APIs, it's important to know the structure of the graph. We're showing you the exact source code for graph construction, and the graph's corresponding node and edge tables, to make things easier to read. % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 from random import choice import matplotlib.pyplot as plt import networkx as nx import numpy as np import nxviz as nv from nxviz import annotate , highlights from nxviz.plots import despine , rescale , respine /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn(","title":"How to read this notebook"},{"location":"api/high-level-api/#example-graph","text":"We're going to use an example graph, the erdos-renyi graph, to illustrate.","title":"Example Graph"},{"location":"api/high-level-api/#source-code","text":"Here's the source code for graph generation. G = nx . erdos_renyi_graph ( n = 71 , p = 0.1 ) for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"group\" ] = choice ([ \"a\" , \"b\" , \"c\" ]) G . nodes [ n ][ \"value\" ] = np . random . exponential () np . random . seed ( 44 ) for u , v , d in G . edges ( data = True ): G . edges [ u , v ][ \"edge_value\" ] = np . random . exponential () from random import choice u , v = choice ( list ( G . edges ()))","title":"Source code"},{"location":"api/high-level-api/#node-table","text":"from nxviz.utils import edge_table , node_table node_table ( G ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } group value 0 c 1.301247 1 a 0.127580 2 a 0.356859 3 c 0.792939 4 b 0.925250 ... ... ... 66 c 0.906692 67 b 0.095024 68 c 0.687436 69 c 0.366349 70 b 0.253142 71 rows \u00d7 2 columns edge_table ( G ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } edge_value source target 0 1.800854 0 23 1 1.800854 23 0 2 0.110704 0 28 3 0.110704 28 0 4 1.365083 0 35 ... ... ... ... 495 0.220343 68 67 496 1.806456 67 70 497 1.806456 70 67 498 0.557011 68 70 499 0.557011 70 68 500 rows \u00d7 3 columns","title":"Node table"},{"location":"api/high-level-api/#hive-plot","text":"Here's a Hive Plot view of the graph. The Hive plot is appropriate here, because we have one categorical variables with three values by which we can group our nodes. Here's one example where we group the nodes by their group attribute, sort and colour them by their value attribute, and set the transparency of an aged based on the edge's edge_value attribute. We also annotate the grouping on the hive plot. ax = nv . hive ( G , group_by = \"group\" , sort_by = \"value\" , node_color_by = \"value\" , edge_alpha_by = \"edge_value\" , ) annotate . hive_group ( G , group_by = \"group\" , offset = np . pi / 12 ) Here's an alternative visualization where we group and colour the nodes by their group attribute, ignoring the value attribute on the nodes and the edge_value attribute on the edges. ax = nv . hive ( G , group_by = \"group\" , node_color_by = \"group\" ) annotate . hive_group ( G , group_by = \"group\" ) highlights . hive_node ( G , u , group_by = \"group\" ) highlights . hive_node ( G , v , group_by = \"group\" ) highlights . hive_edge ( G , u , v , group_by = \"group\" ) The same consistent API applies to the other plot types.","title":"Hive Plot"},{"location":"api/high-level-api/#arc-plot","text":"ax = nv . arc ( G , group_by = \"group\" , node_color_by = \"group\" , edge_alpha_by = \"edge_value\" ) annotate . arc_group ( G , group_by = \"group\" , ha = \"center\" , rotation = 0 ) highlights . arc_node ( G , u , group_by = \"group\" ) highlights . arc_node ( G , v , group_by = \"group\" ) highlights . arc_edge ( G , source = u , target = v , group_by = \"group\" )","title":"Arc Plot"},{"location":"api/high-level-api/#circos-plot","text":"ax = nv . circos ( G , group_by = \"group\" , node_color_by = \"group\" , edge_alpha_by = \"edge_value\" ) annotate . circos_group ( G , group_by = \"group\" ) highlights . circos_edge ( G , u , v , group_by = \"group\" ) highlights . circos_node ( G , u , group_by = \"group\" ) highlights . circos_node ( G , v , group_by = \"group\" , color = \"blue\" )","title":"Circos Plot"},{"location":"api/high-level-api/#matrix-plot","text":"fig , ax = plt . subplots ( figsize = ( 7 , 7 )) ax = nv . matrix ( G , group_by = \"group\" , sort_by = \"value\" , node_color_by = \"group\" , edge_alpha_by = \"edge_value\" , ) annotate . matrix_group ( G , group_by = \"group\" ) annotate . matrix_block ( G , group_by = \"group\" , color_by = \"group\" , alpha = 0.1 ) highlights . matrix_node ( G , u , group_by = \"group\" , sort_by = \"value\" ) highlights . matrix_node ( G , v , group_by = \"group\" , sort_by = \"value\" , color = \"blue\" ) highlights . matrix_row ( G , u , group_by = \"group\" , sort_by = \"value\" ) highlights . matrix_row ( G , v , group_by = \"group\" , sort_by = \"value\" , axis = \"y\" , color = \"blue\" ) highlights . matrix_edge ( G , u , v , group_by = \"group\" , sort_by = \"value\" )","title":"Matrix Plot"},{"location":"api/low-level-api/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Low-level API The nxviz low level API is one that provides the most flexibility for constructing rational graph visualizations. As always, with rational graph visualizations, there is a process involved that helps us compose together beautiful visualizations. We first concern ourselves with the node placement using the layout functions. Then, we concern ourselves with data-driven visual styling of the nodes. After that, we figure out how to draw edges (whether as lines or bezier curves) and style them according to data. % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 Example As an example, let's see how we make can make customizations to the Circos plot by using the low-level API. For some of these things, we might be able to accomplish them using the higher level API, but we will intentionally show the low-level way of handling these customizations so that you can have a feel for how you can implement low-level customizations. from random import choice import networkx as nx import numpy as np G = nx . erdos_renyi_graph ( n = 71 , p = 0.1 ) for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"group\" ] = choice ([ \"a\" , \"b\" , \"c\" ]) G . nodes [ n ][ \"value\" ] = np . random . exponential () np . random . seed ( 44 ) for u , v , d in G . edges ( data = True ): G . edges [ u , v ][ \"edge_value\" ] = np . random . exponential () Node and Edge Table The node and edge tables are the low-level data structures that are used in creating network visualizations. These are pandas DataFrames. from nxviz import utils nt = utils . node_table ( G ) nt . head () /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } group value 0 c 0.954970 1 c 0.305390 2 a 0.771034 3 a 0.439279 4 c 0.077081 The node table is indexed by node ID, and all of the metadata attributes are stored as columns. et = utils . edge_table ( G ) et . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } edge_value source target 0 1.800854 0 2 1 1.800854 2 0 2 0.110704 0 16 3 0.110704 16 0 4 1.365083 0 22 For the edge table, the \"source\" and \"target\" columns are the node IDs in the node table. Every other column is a metadata field. The index carries no semantic meaning here. Circos layout Following the principles of rational graph visualization, we start by declaring the layout that we want. Since in our example we'll be using the Circos plot layout, let's start by obtaining the (x, y) coordinate positions of each node that we want to plot. The nxviz.layouts module contains the circos plot layout function that we'll want. Underneath the hood, it uses pandas' group-by and sorting functionality to get nodes into the correct order that we want. If you wish to group and sort in a customized fashion, then you'll have to implement the functionality yourself. from nxviz import layouts pos = layouts . circos ( nt , group_by = \"group\" ) Node styling Next, we concern ourselves with the styling of the nodes. Here, the nxviz.encodings submodule becomes useful for us. When drawing nodes, their color, transparency, and size can be most naturally mapped to data. Transparency requires that a quantitative value be mappable to the interval (0, 1). Size requires that a quantitative value be mappable to the positive floats (0, +inf). Color is the trickiest of them all: A categorical variable should be mapped to a categorical colormap. A continuous variable should be mapped to a continuous colormap. The choice of colormap is always going to be dependent on the user. If you're looking for a guide on how to choose colormaps, the Points of View guide to colors is a very good resource to start with. How do we handle styling of nodes? The primary way of doing so is to have a Python function that maps from the node table's column of values (passed in as a pandas Series) to any color specification that matplotlib can handle: Strings: \"black\", \"yellow\", \"blue\", etc. RGB(A): (0.1, 0.8, 0.3, 0.5) Hexadecimal: #FFFFFF , #000000 , #A7C91F Here's two examples, one using a highly custom mapping, and the other using matplotlib's color maps. import matplotlib.pyplot as plt import pandas as pd from nxviz import encodings as aes def group_colormap ( data : pd . Series ): cmap = { \"a\" : \"black\" , \"b\" : \"blue\" , \"c\" : \"red\" } return data . apply ( lambda x : cmap . get ( x )) def value_colormap ( data : pd . Series ): \"\"\"Value colormap.\"\"\" norm = plt . cm . Normalize ( vmin = data . min (), vmax = data . max ()) cmap = plt . cm . get_cmap ( \"viridis\" ) return data . apply ( lambda x : cmap ( norm ( x ))) def node_size ( data : pd . Series ): return data . apply ( np . sqrt ) We can now combine everything together, into something that basically reconstructs nodes.draw . import inspect from nxviz import nodes , plots print ( inspect . getsource ( nodes . draw )) def draw( G: nx.Graph, layout_func: Callable, group_by: Hashable, sort_by: Hashable, color_by: Hashable = None, alpha_by: Hashable = None, size_by: Hashable = None, layout_kwargs: Dict = {}, encodings_kwargs: Dict = {}, rescale_func=rescale, ax=None, ): \"\"\"Draw nodes to matplotlib axes. ## Parameters - `G`: The graph to plot. - `layout_func`: One of the node layout functions from `nxviz.layout`. - `group_by`: Categorical attribute key to group nodes by. - `sort_by`: Quantitative or ordinal attribute key to sort nodes. - `color_by`: Node attribute key to color nodes by. - `alpha_by`: Quantitative node attribute key to set transparency. - `size_by`: Quantitative node attribute key to set node size. - `layout_kwargs`: Keyword arguments to pass to the appropriate layout function. - `encodings_kwargs`: A dictionary of kwargs to determine the visual properties of the node. - `linefunc_kwargs`: All other keyword arguments passed in will be passed onto the appropriate linefunc. Special keyword arguments for `encodings_kwargs` include: - `size_scale`: A scaling factor for all node radii. Equivalent to multiplying all node radii by this number. - `alpha_scale`: A scaling factor for all nodes' transparencies. Equivalent to multiplying all alphas by this number. The default transparency is 1.0. If you need to make the nodes transparent, use a value smaller than one. - `alpha_bounds`: The bounds for transparency. Should be a tuple of `(lower, upper)` numbers. This keyword argument lets us manually set the bounds that we wish to have for 0 opacity (i.e. transparent) to 1.0 opacity (i.e. opaque.) Everything else passed in here will be passed to the matplotlib Patch constructor; see `nxviz.lines` for more information. \"\"\" if ax is None: ax = plt.gca() nt = node_table(G) pos = layout_func(nt, group_by, sort_by, **layout_kwargs) node_color = node_colors(nt, color_by) encodings_kwargs = deepcopy(encodings_kwargs) alpha = transparency(nt, alpha_by) * encodings_kwargs.pop(\"alpha_scale\", 1) size = node_size(nt, size_by) * encodings_kwargs.pop(\"size_scale\", 1) patches = node_glyphs(nt, pos, node_color, alpha, size, **encodings_kwargs) for patch in patches: ax.add_patch(patch) rescale_func(G) return pos ax = plt . gca () # Customize node styling nt = utils . node_table ( G ) pos = layouts . circos ( nt , group_by = \"group\" , sort_by = \"value\" ) node_color = group_colormap ( nt [ \"group\" ]) alpha = nodes . transparency ( nt , alpha_by = None ) size = nodes . node_size ( nt , \"value\" ) patches = nodes . node_glyphs ( nt , pos , node_color = node_color , alpha = alpha , size = size ) for patch in patches : ax . add_patch ( patch ) plots . rescale ( G ) plots . aspect_equal () Voila! We now have a sonic hedgehog-style node layout! Pretty cool, isn't it? Adding in edges Once the node layout is complete, customizing the edge styling is a matter of concerning ourselves with: Line width Transparency Color We could customize more, but these three are the most commonly-used for mapping data to style. As with node layouts, we basically have to re-create nxviz.edges.draw with customized data-to-style mapping functions. from nxviz import edges print ( inspect . getsource ( edges . draw )) def draw( G: nx.Graph, pos: Dict[Hashable, np.ndarray], lines_func: Callable, color_by: Hashable = None, node_color_by: Hashable = None, lw_by: Hashable = None, alpha_by: Hashable = None, ax=None, encodings_kwargs: Dict = {}, **linefunc_kwargs, ): \"\"\"Draw edges to matplotlib axes. ## Parameters - `G`: A NetworkX graph. - `pos`: A dictionary mapping for x,y coordinates of a node. - `lines_func`: One of the line drawing functions from `nxviz.lines` - `color_by`: Categorical or quantitative edge attribute key to color edges by. There are two special value for this parameter when using directed graphs: \"source_node_color\" and \"target_node_color\". If these values are set, then `node_color_by` also needs to be set. - `node_color_by`: Node metadata attribute key that has been used to color nodes. - `node_color_by`: Node metadata attribute key that has been used to color nodes. - `lw_by`: Quantitative edge attribute key to determine line width. - `alpha_by`: Quantitative edge attribute key to determine transparency. - `ax`: Matplotlib axes object to plot onto. - `encodings_kwargs`: A dictionary of kwargs to determine the visual properties of the edge. - `linefunc_kwargs`: All other keyword arguments passed in will be passed onto the appropriate linefunc. Special keyword arguments for `encodings_kwargs` include: - `lw_scale`: A scaling factor for all edges' line widths. Equivalent to multiplying all line widths by this number. - `alpha_scale`: A scaling factor for all edges' line transparencies. Equivalent to multiplying all alphas by this number. The default transparency is 0.1, so an alpha_scale of any number greater than or equal to 10 will result in 100% opaque lines. - `alpha_bounds`: The bounds for transparency. Should be a tuple of `(lower, upper)` numbers. This keyword argument lets us manually set the bounds that we wish to have for 0 opacity (i.e. transparent) to 1.0 opacity (i.e. opaque.) Everything else passed in here will be passed to the matplotlib Patch constructor; see `nxviz.lines` for more information. \"\"\" nt = node_table(G) et = edge_table(G) if ax is None: ax = plt.gca() validate_color_by(G, color_by, node_color_by) edge_color = edge_colors(et, nt, color_by, node_color_by) encodings_kwargs = deepcopy(encodings_kwargs) lw = line_width(et, lw_by) * encodings_kwargs.pop(\"lw_scale\", 1.0) alpha_bounds = encodings_kwargs.get(\"alpha_bounds\", None) alpha = transparency(et, alpha_by, alpha_bounds) * encodings_kwargs.pop( \"alpha_scale\", 1.0 ) aes_kw = {\"facecolor\": \"none\"} aes_kw.update(encodings_kwargs) patches = lines_func( et, pos, edge_color=edge_color, alpha=alpha, lw=lw, aes_kw=aes_kw, **linefunc_kwargs, ) for patch in patches: ax.add_patch(patch) from nxviz import lines # Customize node styling ax = plt . gca () nt = utils . node_table ( G ) pos = layouts . circos ( nt , group_by = \"group\" , sort_by = \"value\" ) node_color = group_colormap ( nt [ \"group\" ]) alpha = nodes . transparency ( nt , alpha_by = None ) size = nodes . node_size ( nt , \"value\" ) patches = nodes . node_glyphs ( nt , pos , node_color = node_color , alpha = alpha , size = size ) for patch in patches : ax . add_patch ( patch ) # Customize edge styling et = utils . edge_table ( G ) edge_color = edges . edge_colors ( et , nt = None , color_by = None , node_color_by = None ) lw = np . sqrt ( et [ \"edge_value\" ]) alpha = edges . transparency ( et , alpha_by = None ) patches = lines . circos ( et , pos , edge_color = edge_color , alpha = alpha , lw = lw , aes_kw = { \"fc\" : \"none\" } ) for patch in patches : ax . add_patch ( patch ) plots . rescale ( G ) plots . aspect_equal () plots . despine () Looking at the plot, we might find that expressing the edges' edge_value as line width might not be that effective. Instead, we might want to express it using alpha. from nxviz import lines # Customize node styling ax = plt . gca () nt = utils . node_table ( G ) pos = layouts . circos ( nt , group_by = \"group\" , sort_by = \"value\" ) node_color = group_colormap ( nt [ \"group\" ]) alpha = nodes . transparency ( nt , alpha_by = None ) size = nodes . node_size ( nt , \"value\" ) patches = nodes . node_glyphs ( nt , pos , node_color = node_color , alpha = alpha , size = size ) for patch in patches : ax . add_patch ( patch ) # Customize edge styling et = utils . edge_table ( G ) edge_color = edges . edge_colors ( et , nt = None , color_by = None , node_color_by = None ) lw = edges . line_width ( et , lw_by = None ) alpha = edges . transparency ( et , alpha_by = \"edge_value\" ) patches = lines . circos ( et , pos , edge_color = edge_color , alpha = alpha , lw = lw , aes_kw = { \"fc\" : \"none\" } ) for patch in patches : ax . add_patch ( patch ) plots . rescale ( G ) plots . aspect_equal () plots . despine () Looking at this plot, it's a lot easier for us to see the important edges (as visualized by the alpha value). Conclusion Throughout this notebook, we dropped down from the mid-level API to the low-level API, where we get to customize node and edge styling to our heart's content. The patterns are easy to follow. For nodes, we customize the size, color and transparency . For edges we customize the line width, color, and transparency . We can then compose them together into the plots we see above.","title":"Low-level API"},{"location":"api/low-level-api/#low-level-api","text":"The nxviz low level API is one that provides the most flexibility for constructing rational graph visualizations. As always, with rational graph visualizations, there is a process involved that helps us compose together beautiful visualizations. We first concern ourselves with the node placement using the layout functions. Then, we concern ourselves with data-driven visual styling of the nodes. After that, we figure out how to draw edges (whether as lines or bezier curves) and style them according to data. % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2","title":"Low-level API"},{"location":"api/low-level-api/#example","text":"As an example, let's see how we make can make customizations to the Circos plot by using the low-level API. For some of these things, we might be able to accomplish them using the higher level API, but we will intentionally show the low-level way of handling these customizations so that you can have a feel for how you can implement low-level customizations. from random import choice import networkx as nx import numpy as np G = nx . erdos_renyi_graph ( n = 71 , p = 0.1 ) for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"group\" ] = choice ([ \"a\" , \"b\" , \"c\" ]) G . nodes [ n ][ \"value\" ] = np . random . exponential () np . random . seed ( 44 ) for u , v , d in G . edges ( data = True ): G . edges [ u , v ][ \"edge_value\" ] = np . random . exponential ()","title":"Example"},{"location":"api/low-level-api/#node-and-edge-table","text":"The node and edge tables are the low-level data structures that are used in creating network visualizations. These are pandas DataFrames. from nxviz import utils nt = utils . node_table ( G ) nt . head () /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } group value 0 c 0.954970 1 c 0.305390 2 a 0.771034 3 a 0.439279 4 c 0.077081 The node table is indexed by node ID, and all of the metadata attributes are stored as columns. et = utils . edge_table ( G ) et . head () .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } edge_value source target 0 1.800854 0 2 1 1.800854 2 0 2 0.110704 0 16 3 0.110704 16 0 4 1.365083 0 22 For the edge table, the \"source\" and \"target\" columns are the node IDs in the node table. Every other column is a metadata field. The index carries no semantic meaning here.","title":"Node and Edge Table"},{"location":"api/low-level-api/#circos-layout","text":"Following the principles of rational graph visualization, we start by declaring the layout that we want. Since in our example we'll be using the Circos plot layout, let's start by obtaining the (x, y) coordinate positions of each node that we want to plot. The nxviz.layouts module contains the circos plot layout function that we'll want. Underneath the hood, it uses pandas' group-by and sorting functionality to get nodes into the correct order that we want. If you wish to group and sort in a customized fashion, then you'll have to implement the functionality yourself. from nxviz import layouts pos = layouts . circos ( nt , group_by = \"group\" )","title":"Circos layout"},{"location":"api/low-level-api/#node-styling","text":"Next, we concern ourselves with the styling of the nodes. Here, the nxviz.encodings submodule becomes useful for us. When drawing nodes, their color, transparency, and size can be most naturally mapped to data. Transparency requires that a quantitative value be mappable to the interval (0, 1). Size requires that a quantitative value be mappable to the positive floats (0, +inf). Color is the trickiest of them all: A categorical variable should be mapped to a categorical colormap. A continuous variable should be mapped to a continuous colormap. The choice of colormap is always going to be dependent on the user. If you're looking for a guide on how to choose colormaps, the Points of View guide to colors is a very good resource to start with. How do we handle styling of nodes? The primary way of doing so is to have a Python function that maps from the node table's column of values (passed in as a pandas Series) to any color specification that matplotlib can handle: Strings: \"black\", \"yellow\", \"blue\", etc. RGB(A): (0.1, 0.8, 0.3, 0.5) Hexadecimal: #FFFFFF , #000000 , #A7C91F Here's two examples, one using a highly custom mapping, and the other using matplotlib's color maps. import matplotlib.pyplot as plt import pandas as pd from nxviz import encodings as aes def group_colormap ( data : pd . Series ): cmap = { \"a\" : \"black\" , \"b\" : \"blue\" , \"c\" : \"red\" } return data . apply ( lambda x : cmap . get ( x )) def value_colormap ( data : pd . Series ): \"\"\"Value colormap.\"\"\" norm = plt . cm . Normalize ( vmin = data . min (), vmax = data . max ()) cmap = plt . cm . get_cmap ( \"viridis\" ) return data . apply ( lambda x : cmap ( norm ( x ))) def node_size ( data : pd . Series ): return data . apply ( np . sqrt ) We can now combine everything together, into something that basically reconstructs nodes.draw . import inspect from nxviz import nodes , plots print ( inspect . getsource ( nodes . draw )) def draw( G: nx.Graph, layout_func: Callable, group_by: Hashable, sort_by: Hashable, color_by: Hashable = None, alpha_by: Hashable = None, size_by: Hashable = None, layout_kwargs: Dict = {}, encodings_kwargs: Dict = {}, rescale_func=rescale, ax=None, ): \"\"\"Draw nodes to matplotlib axes. ## Parameters - `G`: The graph to plot. - `layout_func`: One of the node layout functions from `nxviz.layout`. - `group_by`: Categorical attribute key to group nodes by. - `sort_by`: Quantitative or ordinal attribute key to sort nodes. - `color_by`: Node attribute key to color nodes by. - `alpha_by`: Quantitative node attribute key to set transparency. - `size_by`: Quantitative node attribute key to set node size. - `layout_kwargs`: Keyword arguments to pass to the appropriate layout function. - `encodings_kwargs`: A dictionary of kwargs to determine the visual properties of the node. - `linefunc_kwargs`: All other keyword arguments passed in will be passed onto the appropriate linefunc. Special keyword arguments for `encodings_kwargs` include: - `size_scale`: A scaling factor for all node radii. Equivalent to multiplying all node radii by this number. - `alpha_scale`: A scaling factor for all nodes' transparencies. Equivalent to multiplying all alphas by this number. The default transparency is 1.0. If you need to make the nodes transparent, use a value smaller than one. - `alpha_bounds`: The bounds for transparency. Should be a tuple of `(lower, upper)` numbers. This keyword argument lets us manually set the bounds that we wish to have for 0 opacity (i.e. transparent) to 1.0 opacity (i.e. opaque.) Everything else passed in here will be passed to the matplotlib Patch constructor; see `nxviz.lines` for more information. \"\"\" if ax is None: ax = plt.gca() nt = node_table(G) pos = layout_func(nt, group_by, sort_by, **layout_kwargs) node_color = node_colors(nt, color_by) encodings_kwargs = deepcopy(encodings_kwargs) alpha = transparency(nt, alpha_by) * encodings_kwargs.pop(\"alpha_scale\", 1) size = node_size(nt, size_by) * encodings_kwargs.pop(\"size_scale\", 1) patches = node_glyphs(nt, pos, node_color, alpha, size, **encodings_kwargs) for patch in patches: ax.add_patch(patch) rescale_func(G) return pos ax = plt . gca () # Customize node styling nt = utils . node_table ( G ) pos = layouts . circos ( nt , group_by = \"group\" , sort_by = \"value\" ) node_color = group_colormap ( nt [ \"group\" ]) alpha = nodes . transparency ( nt , alpha_by = None ) size = nodes . node_size ( nt , \"value\" ) patches = nodes . node_glyphs ( nt , pos , node_color = node_color , alpha = alpha , size = size ) for patch in patches : ax . add_patch ( patch ) plots . rescale ( G ) plots . aspect_equal () Voila! We now have a sonic hedgehog-style node layout! Pretty cool, isn't it?","title":"Node styling"},{"location":"api/low-level-api/#adding-in-edges","text":"Once the node layout is complete, customizing the edge styling is a matter of concerning ourselves with: Line width Transparency Color We could customize more, but these three are the most commonly-used for mapping data to style. As with node layouts, we basically have to re-create nxviz.edges.draw with customized data-to-style mapping functions. from nxviz import edges print ( inspect . getsource ( edges . draw )) def draw( G: nx.Graph, pos: Dict[Hashable, np.ndarray], lines_func: Callable, color_by: Hashable = None, node_color_by: Hashable = None, lw_by: Hashable = None, alpha_by: Hashable = None, ax=None, encodings_kwargs: Dict = {}, **linefunc_kwargs, ): \"\"\"Draw edges to matplotlib axes. ## Parameters - `G`: A NetworkX graph. - `pos`: A dictionary mapping for x,y coordinates of a node. - `lines_func`: One of the line drawing functions from `nxviz.lines` - `color_by`: Categorical or quantitative edge attribute key to color edges by. There are two special value for this parameter when using directed graphs: \"source_node_color\" and \"target_node_color\". If these values are set, then `node_color_by` also needs to be set. - `node_color_by`: Node metadata attribute key that has been used to color nodes. - `node_color_by`: Node metadata attribute key that has been used to color nodes. - `lw_by`: Quantitative edge attribute key to determine line width. - `alpha_by`: Quantitative edge attribute key to determine transparency. - `ax`: Matplotlib axes object to plot onto. - `encodings_kwargs`: A dictionary of kwargs to determine the visual properties of the edge. - `linefunc_kwargs`: All other keyword arguments passed in will be passed onto the appropriate linefunc. Special keyword arguments for `encodings_kwargs` include: - `lw_scale`: A scaling factor for all edges' line widths. Equivalent to multiplying all line widths by this number. - `alpha_scale`: A scaling factor for all edges' line transparencies. Equivalent to multiplying all alphas by this number. The default transparency is 0.1, so an alpha_scale of any number greater than or equal to 10 will result in 100% opaque lines. - `alpha_bounds`: The bounds for transparency. Should be a tuple of `(lower, upper)` numbers. This keyword argument lets us manually set the bounds that we wish to have for 0 opacity (i.e. transparent) to 1.0 opacity (i.e. opaque.) Everything else passed in here will be passed to the matplotlib Patch constructor; see `nxviz.lines` for more information. \"\"\" nt = node_table(G) et = edge_table(G) if ax is None: ax = plt.gca() validate_color_by(G, color_by, node_color_by) edge_color = edge_colors(et, nt, color_by, node_color_by) encodings_kwargs = deepcopy(encodings_kwargs) lw = line_width(et, lw_by) * encodings_kwargs.pop(\"lw_scale\", 1.0) alpha_bounds = encodings_kwargs.get(\"alpha_bounds\", None) alpha = transparency(et, alpha_by, alpha_bounds) * encodings_kwargs.pop( \"alpha_scale\", 1.0 ) aes_kw = {\"facecolor\": \"none\"} aes_kw.update(encodings_kwargs) patches = lines_func( et, pos, edge_color=edge_color, alpha=alpha, lw=lw, aes_kw=aes_kw, **linefunc_kwargs, ) for patch in patches: ax.add_patch(patch) from nxviz import lines # Customize node styling ax = plt . gca () nt = utils . node_table ( G ) pos = layouts . circos ( nt , group_by = \"group\" , sort_by = \"value\" ) node_color = group_colormap ( nt [ \"group\" ]) alpha = nodes . transparency ( nt , alpha_by = None ) size = nodes . node_size ( nt , \"value\" ) patches = nodes . node_glyphs ( nt , pos , node_color = node_color , alpha = alpha , size = size ) for patch in patches : ax . add_patch ( patch ) # Customize edge styling et = utils . edge_table ( G ) edge_color = edges . edge_colors ( et , nt = None , color_by = None , node_color_by = None ) lw = np . sqrt ( et [ \"edge_value\" ]) alpha = edges . transparency ( et , alpha_by = None ) patches = lines . circos ( et , pos , edge_color = edge_color , alpha = alpha , lw = lw , aes_kw = { \"fc\" : \"none\" } ) for patch in patches : ax . add_patch ( patch ) plots . rescale ( G ) plots . aspect_equal () plots . despine () Looking at the plot, we might find that expressing the edges' edge_value as line width might not be that effective. Instead, we might want to express it using alpha. from nxviz import lines # Customize node styling ax = plt . gca () nt = utils . node_table ( G ) pos = layouts . circos ( nt , group_by = \"group\" , sort_by = \"value\" ) node_color = group_colormap ( nt [ \"group\" ]) alpha = nodes . transparency ( nt , alpha_by = None ) size = nodes . node_size ( nt , \"value\" ) patches = nodes . node_glyphs ( nt , pos , node_color = node_color , alpha = alpha , size = size ) for patch in patches : ax . add_patch ( patch ) # Customize edge styling et = utils . edge_table ( G ) edge_color = edges . edge_colors ( et , nt = None , color_by = None , node_color_by = None ) lw = edges . line_width ( et , lw_by = None ) alpha = edges . transparency ( et , alpha_by = \"edge_value\" ) patches = lines . circos ( et , pos , edge_color = edge_color , alpha = alpha , lw = lw , aes_kw = { \"fc\" : \"none\" } ) for patch in patches : ax . add_patch ( patch ) plots . rescale ( G ) plots . aspect_equal () plots . despine () Looking at this plot, it's a lot easier for us to see the important edges (as visualized by the alpha value).","title":"Adding in edges"},{"location":"api/low-level-api/#conclusion","text":"Throughout this notebook, we dropped down from the mid-level API to the low-level API, where we get to customize node and edge styling to our heart's content. The patterns are easy to follow. For nodes, we customize the size, color and transparency . For edges we customize the line width, color, and transparency . We can then compose them together into the plots we see above.","title":"Conclusion"},{"location":"api/mid-level-api/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Mid-Level API As a graph visualization package built on top of NetworkX, nxviz 's design is highly inspired by the grammar of graphics. In particular, we see network visualizations as being composed of two main components, which correspond to the two objects that comprise a graph: Nodes: their layout (position, grouping & ordering), and visual styling (color, size, and transparency). Edges: their visual styling (color, width, and transparency). In addition to these, we may choose to add annotations and highlights onto the network visualization, such as node and/or edge labels, particular nodes and/or edges being highlighted, color bars or legends, and more. As such, the low-level functional API is designed around these ideas. In this notebook, we would like to highlight how the low-level API can be used to compose beautiful network visualizations, as long as one structures one's thinking around these principles. % load_ext autoreload % autoreload 2 % config InlineBackend . figure_format = 'retina' An example graph To illustrate, we will use the Karate Club Graph from NetworkX's library. from random import choice import networkx as nx import io import urllib.request as urllib import zipfile import matplotlib.pyplot as plt import networkx as nx url = \"http://www-personal.umich.edu/~mejn/netdata/football.zip\" sock = urllib . urlopen ( url ) # open URL s = io . BytesIO ( sock . read ()) # read into BytesIO \"file\" sock . close () zf = zipfile . ZipFile ( s ) # zipfile object txt = zf . read ( \"football.txt\" ) . decode () # read info file gml = zf . read ( \"football.gml\" ) . decode () # read gml data # throw away bogus first line with # from mejn files gml = gml . split ( \" \\n \" )[ 1 :] G = nx . parse_gml ( gml ) # parse gml data print ( txt ) mapping = dict ( { 0 : \"Atlantic Coast\" , 1 : \"Big East\" , 2 : \"Big Ten\" , 3 : \"Big Twelve\" , 4 : \"Conference USA\" , 5 : \"Independents\" , 6 : \"Mid-American\" , 7 : \"Mountain West\" , 8 : \"Pacific Ten\" , 9 : \"Southeastern\" , 10 : \"Sun Belt\" , 11 : \"Western Athletic\" , } ) for node , data in G . nodes ( data = True ): G . nodes [ node ][ \"conference\" ] = mapping [ data [ \"value\" ]] The file football.gml contains the network of American football games between Division IA colleges during regular season Fall 2000, as compiled by M. Girvan and M. Newman. The nodes have values that indicate to which conferences they belong. The values are as follows: 0 = Atlantic Coast 1 = Big East 2 = Big Ten 3 = Big Twelve 4 = Conference USA 5 = Independents 6 = Mid-American 7 = Mountain West 8 = Pacific Ten 9 = Southeastern 10 = Sun Belt 11 = Western Athletic If you make use of these data, please cite M. Girvan and M. E. J. Newman, Community structure in social and biological networks, Proc. Natl. Acad. Sci. USA 99, 7821-7826 (2002). Correction: Two edges were erroneously duplicated in this data set, and have been removed (21 SEP 2014) Visualization using NetworkX's built-in facilities NetworkX does come with its own built-in visualization facilities. Let's see what visualizations we get. nx . draw ( G ) That looks a bit like a hairball. How can we make it look nicer? Node Layout The first thing we should worry about is the node layout. This specifically refers to how nodes are positioned on the 2D plane. In a rational graph visualization, node placement should always take priority, as nodes represent entities with properties that we can grasp. The Circos plot layout lays out the nodes around the circumference of a circle. Hence, by stating up-front that we want a Circos layout, we take care of the first step of graph visualization, that is node placement. The nodes module provides a bunch of node drawing algorithms. They all take in the graph object G and return a position dictionary. That position dictionary is necessary for drawing edges, as we'll see in a moment. from nxviz import nodes pos = nodes . circos ( G ) /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( Right now, it doesn't look like much - a blue donut, basically. That is because there are a bunch of circles of radius 1 (the default radius) that are overlapping with one another. To make things a bit more informative, we should probably group the nodes by their conference. Here is where nxviz's API becomes apparent. We can refine the positioning of the nodes by specifying how to group them and sort them. This is accomplished by specifying the group_by and sort_by keyword arguments. Let's see the effect of specifying group_by : pos = nodes . circos ( G , group_by = \"conference\" ) You might be wondering, why didn't that do anything? Actually, it did, but things are not yet visually apparent because we have only concerned ourselves with the positions of the nodes and not the visual properties of the nodes. The visual properties of the node that can be mapped to data are the color, the transparency, and the node size. By default, node colors are blue, transparency (the alpha parameter in matplotlib) is 1, and node size is 1. Let's see how we can declare that we want our nodes to be coloured by conference while also being ordered by conference. pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) Things are starting to look promising! Though, if I were to comment on it, the plot is also still quite ugly. Let's start by applying a uniform scaling factor to all of the nodes to scale them to the size of the plot. (This is the size_scale encoding keyword argument that we'll be specifying below.) pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) The nodes look a bit more appropriately sized! The Circos plot still looks a bit squishy though. There's some adjustments we need to do to the plot to make it look nice. We need to remove the spines and ticks to get rid of the boxiness effect. We also need to make the aspect ratio on the x- and y-axes equal. despine() will accomplish the first. from nxviz.plots import aspect_equal , despine pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) despine () Putting it together with aspect_equal() will get us to a good starting point. pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) despine () aspect_equal () Voila! With the nodes rationally laid out, we have an awesome starting point for adding in the edges. Edge drawing requires that we have the positions of the nodes available. That we obtain from the nodes.circos (or other node drawing) function. We can then pass it to any of the edge drawing functions. When drawing edges, because we are drawing relations and not entities, we are no longer concerned with grouping and sorting. Instead, we are concerned with only the visual properties of the lines. The ones that are most easily mappable to data are: Line width Transparency Line color The edges.circos function is the most logical here, so we'll kick off with that one. from nxviz import edges pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) edges . circos ( G , pos ) despine () aspect_equal () An alternative to drawing circos edges is to draw lines directly for each edge. pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) edges . line ( G , pos ) despine () aspect_equal () Regardless of which edge drawing method we choose, the chart might not be sufficiently ready for our purposes, though. After all, we have no idea what groups map to which color. If we annotate the circos group onto the plot, it becomes much clearer which colors map to which group. from nxviz import annotate pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) edges . circos ( G , pos ) annotate . circos_group ( G , group_by = \"conference\" ) despine () aspect_equal () Now it is clear that there are quite a lot of within-conference edges, and only some cross-conference edges between teams. Other layouts Arc layout pos = nodes . arc ( G , group_by = \"conference\" , color_by = \"conference\" ) edges . arc ( G , pos ) annotate . arc_group ( G , group_by = \"conference\" ) despine () aspect_equal () Parallel coordinates layout from nxviz import edges , nodes pos = nodes . parallel ( G , group_by = \"conference\" , color_by = \"conference\" ) edges . line ( G , pos ) annotate . parallel_group ( G , group_by = \"conference\" ) despine () aspect_equal () The parallel coordinates layout might not necessarily be the most informative for this graph dataset, but we still show it here just to give you a flavour for what is possible with it. It may be more suited to bipartite graphs, which explicitly do not allow for edges within a single group. Hive plot layout The hive plot is a bit special, in that it is suitable for only plotting a maximum of 3 groups. If we isolate nodes from just the Atlantic Coast, Independents, and Sun Belt, then we have a suitable way of plotting hive plots. Grouping is crucial to the Hive plot; we........ Notice here that we take advantage of the node_table version of a graph's nodes, which is essentially a listing of all of the nodes and their properties. The node table works well for unipartite graphs, but needs to be modified for bipartite graphs. import numpy as np from nxviz import nodes from nxviz.utils import node_table conferences = [ \"Atlantic Coast\" , \"Independents\" , \"Sun Belt\" ] nt = node_table ( G ) wanted_nodes = nt . query ( \"`conference` in @conferences\" ) . index G_sub = G . subgraph ( wanted_nodes ) size_scale = 0.5 # radius = 2 pos = nodes . hive ( G_sub , group_by = \"conference\" , color_by = \"conference\" ) pos_cloned = nodes . hive ( G_sub , group_by = \"conference\" , color_by = \"conference\" , layout_kwargs = dict ( rotation = np . pi / 6 ), ) edges . hive ( G_sub , pos , pos_cloned = pos_cloned ) annotate . node_colormapping ( G_sub , color_by = \"conference\" ) despine () aspect_equal () And here, we see an interesting pattern show up that might not have been visible earlier on: The Atlantic Coast teams have a lot of in-group edges than between-group edges, while the independents appear to have lots more between-group edges than in-group edges. Conclusions This notebook's intent is to show you how the mid-level API of nxviz expresses a thought framework for drawing networks in a rational fashion. We start with a particular layout (positions) for the nodes, deciding on their grouping and ordering. We then declare their size, color, and transparency, based on data attributes that are present on there. Next, we declare the way to draw edges. Each layout has its own particular idiomatic edge drawing method, and usually the easiest way to handle this is to use the corresponding edges function. APIs that live at a higher level of abstraction usually imply more restrictions, as the intent here is usually to trade off customizable details for simplicity. The mid-level API allows us to gain finer-grained control over plots while remaining declarative. Changing the colormap, in particular, is out of scope for the mid-level API. The highest level of the nxviz API is object-based and opinionatedly pairs certain node layouts with certain edge drawing functions, not allowing for any customization there. The lowest-level API is where one interacts with the lines, layouts, positions directly, exposing more direct interaction with matplotlib .","title":"Mid-level API"},{"location":"api/mid-level-api/#mid-level-api","text":"As a graph visualization package built on top of NetworkX, nxviz 's design is highly inspired by the grammar of graphics. In particular, we see network visualizations as being composed of two main components, which correspond to the two objects that comprise a graph: Nodes: their layout (position, grouping & ordering), and visual styling (color, size, and transparency). Edges: their visual styling (color, width, and transparency). In addition to these, we may choose to add annotations and highlights onto the network visualization, such as node and/or edge labels, particular nodes and/or edges being highlighted, color bars or legends, and more. As such, the low-level functional API is designed around these ideas. In this notebook, we would like to highlight how the low-level API can be used to compose beautiful network visualizations, as long as one structures one's thinking around these principles. % load_ext autoreload % autoreload 2 % config InlineBackend . figure_format = 'retina'","title":"Mid-Level API"},{"location":"api/mid-level-api/#an-example-graph","text":"To illustrate, we will use the Karate Club Graph from NetworkX's library. from random import choice import networkx as nx import io import urllib.request as urllib import zipfile import matplotlib.pyplot as plt import networkx as nx url = \"http://www-personal.umich.edu/~mejn/netdata/football.zip\" sock = urllib . urlopen ( url ) # open URL s = io . BytesIO ( sock . read ()) # read into BytesIO \"file\" sock . close () zf = zipfile . ZipFile ( s ) # zipfile object txt = zf . read ( \"football.txt\" ) . decode () # read info file gml = zf . read ( \"football.gml\" ) . decode () # read gml data # throw away bogus first line with # from mejn files gml = gml . split ( \" \\n \" )[ 1 :] G = nx . parse_gml ( gml ) # parse gml data print ( txt ) mapping = dict ( { 0 : \"Atlantic Coast\" , 1 : \"Big East\" , 2 : \"Big Ten\" , 3 : \"Big Twelve\" , 4 : \"Conference USA\" , 5 : \"Independents\" , 6 : \"Mid-American\" , 7 : \"Mountain West\" , 8 : \"Pacific Ten\" , 9 : \"Southeastern\" , 10 : \"Sun Belt\" , 11 : \"Western Athletic\" , } ) for node , data in G . nodes ( data = True ): G . nodes [ node ][ \"conference\" ] = mapping [ data [ \"value\" ]] The file football.gml contains the network of American football games between Division IA colleges during regular season Fall 2000, as compiled by M. Girvan and M. Newman. The nodes have values that indicate to which conferences they belong. The values are as follows: 0 = Atlantic Coast 1 = Big East 2 = Big Ten 3 = Big Twelve 4 = Conference USA 5 = Independents 6 = Mid-American 7 = Mountain West 8 = Pacific Ten 9 = Southeastern 10 = Sun Belt 11 = Western Athletic If you make use of these data, please cite M. Girvan and M. E. J. Newman, Community structure in social and biological networks, Proc. Natl. Acad. Sci. USA 99, 7821-7826 (2002). Correction: Two edges were erroneously duplicated in this data set, and have been removed (21 SEP 2014)","title":"An example graph"},{"location":"api/mid-level-api/#visualization-using-networkxs-built-in-facilities","text":"NetworkX does come with its own built-in visualization facilities. Let's see what visualizations we get. nx . draw ( G ) That looks a bit like a hairball. How can we make it look nicer?","title":"Visualization using NetworkX's built-in facilities"},{"location":"api/mid-level-api/#node-layout","text":"The first thing we should worry about is the node layout. This specifically refers to how nodes are positioned on the 2D plane. In a rational graph visualization, node placement should always take priority, as nodes represent entities with properties that we can grasp. The Circos plot layout lays out the nodes around the circumference of a circle. Hence, by stating up-front that we want a Circos layout, we take care of the first step of graph visualization, that is node placement. The nodes module provides a bunch of node drawing algorithms. They all take in the graph object G and return a position dictionary. That position dictionary is necessary for drawing edges, as we'll see in a moment. from nxviz import nodes pos = nodes . circos ( G ) /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( Right now, it doesn't look like much - a blue donut, basically. That is because there are a bunch of circles of radius 1 (the default radius) that are overlapping with one another. To make things a bit more informative, we should probably group the nodes by their conference. Here is where nxviz's API becomes apparent. We can refine the positioning of the nodes by specifying how to group them and sort them. This is accomplished by specifying the group_by and sort_by keyword arguments. Let's see the effect of specifying group_by : pos = nodes . circos ( G , group_by = \"conference\" ) You might be wondering, why didn't that do anything? Actually, it did, but things are not yet visually apparent because we have only concerned ourselves with the positions of the nodes and not the visual properties of the nodes. The visual properties of the node that can be mapped to data are the color, the transparency, and the node size. By default, node colors are blue, transparency (the alpha parameter in matplotlib) is 1, and node size is 1. Let's see how we can declare that we want our nodes to be coloured by conference while also being ordered by conference. pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) Things are starting to look promising! Though, if I were to comment on it, the plot is also still quite ugly. Let's start by applying a uniform scaling factor to all of the nodes to scale them to the size of the plot. (This is the size_scale encoding keyword argument that we'll be specifying below.) pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) The nodes look a bit more appropriately sized! The Circos plot still looks a bit squishy though. There's some adjustments we need to do to the plot to make it look nice. We need to remove the spines and ticks to get rid of the boxiness effect. We also need to make the aspect ratio on the x- and y-axes equal. despine() will accomplish the first. from nxviz.plots import aspect_equal , despine pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) despine () Putting it together with aspect_equal() will get us to a good starting point. pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) despine () aspect_equal () Voila! With the nodes rationally laid out, we have an awesome starting point for adding in the edges. Edge drawing requires that we have the positions of the nodes available. That we obtain from the nodes.circos (or other node drawing) function. We can then pass it to any of the edge drawing functions. When drawing edges, because we are drawing relations and not entities, we are no longer concerned with grouping and sorting. Instead, we are concerned with only the visual properties of the lines. The ones that are most easily mappable to data are: Line width Transparency Line color The edges.circos function is the most logical here, so we'll kick off with that one. from nxviz import edges pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) edges . circos ( G , pos ) despine () aspect_equal () An alternative to drawing circos edges is to draw lines directly for each edge. pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) edges . line ( G , pos ) despine () aspect_equal () Regardless of which edge drawing method we choose, the chart might not be sufficiently ready for our purposes, though. After all, we have no idea what groups map to which color. If we annotate the circos group onto the plot, it becomes much clearer which colors map to which group. from nxviz import annotate pos = nodes . circos ( G , group_by = \"conference\" , color_by = \"conference\" ) edges . circos ( G , pos ) annotate . circos_group ( G , group_by = \"conference\" ) despine () aspect_equal () Now it is clear that there are quite a lot of within-conference edges, and only some cross-conference edges between teams.","title":"Node Layout"},{"location":"api/mid-level-api/#other-layouts","text":"","title":"Other layouts"},{"location":"api/mid-level-api/#arc-layout","text":"pos = nodes . arc ( G , group_by = \"conference\" , color_by = \"conference\" ) edges . arc ( G , pos ) annotate . arc_group ( G , group_by = \"conference\" ) despine () aspect_equal ()","title":"Arc layout"},{"location":"api/mid-level-api/#parallel-coordinates-layout","text":"from nxviz import edges , nodes pos = nodes . parallel ( G , group_by = \"conference\" , color_by = \"conference\" ) edges . line ( G , pos ) annotate . parallel_group ( G , group_by = \"conference\" ) despine () aspect_equal () The parallel coordinates layout might not necessarily be the most informative for this graph dataset, but we still show it here just to give you a flavour for what is possible with it. It may be more suited to bipartite graphs, which explicitly do not allow for edges within a single group.","title":"Parallel coordinates layout"},{"location":"api/mid-level-api/#hive-plot-layout","text":"The hive plot is a bit special, in that it is suitable for only plotting a maximum of 3 groups. If we isolate nodes from just the Atlantic Coast, Independents, and Sun Belt, then we have a suitable way of plotting hive plots. Grouping is crucial to the Hive plot; we........ Notice here that we take advantage of the node_table version of a graph's nodes, which is essentially a listing of all of the nodes and their properties. The node table works well for unipartite graphs, but needs to be modified for bipartite graphs. import numpy as np from nxviz import nodes from nxviz.utils import node_table conferences = [ \"Atlantic Coast\" , \"Independents\" , \"Sun Belt\" ] nt = node_table ( G ) wanted_nodes = nt . query ( \"`conference` in @conferences\" ) . index G_sub = G . subgraph ( wanted_nodes ) size_scale = 0.5 # radius = 2 pos = nodes . hive ( G_sub , group_by = \"conference\" , color_by = \"conference\" ) pos_cloned = nodes . hive ( G_sub , group_by = \"conference\" , color_by = \"conference\" , layout_kwargs = dict ( rotation = np . pi / 6 ), ) edges . hive ( G_sub , pos , pos_cloned = pos_cloned ) annotate . node_colormapping ( G_sub , color_by = \"conference\" ) despine () aspect_equal () And here, we see an interesting pattern show up that might not have been visible earlier on: The Atlantic Coast teams have a lot of in-group edges than between-group edges, while the independents appear to have lots more between-group edges than in-group edges.","title":"Hive plot layout"},{"location":"api/mid-level-api/#conclusions","text":"This notebook's intent is to show you how the mid-level API of nxviz expresses a thought framework for drawing networks in a rational fashion. We start with a particular layout (positions) for the nodes, deciding on their grouping and ordering. We then declare their size, color, and transparency, based on data attributes that are present on there. Next, we declare the way to draw edges. Each layout has its own particular idiomatic edge drawing method, and usually the easiest way to handle this is to use the corresponding edges function. APIs that live at a higher level of abstraction usually imply more restrictions, as the intent here is usually to trade off customizable details for simplicity. The mid-level API allows us to gain finer-grained control over plots while remaining declarative. Changing the colormap, in particular, is out of scope for the mid-level API. The highest level of the nxviz API is object-based and opinionatedly pairs certain node layouts with certain edge drawing functions, not allowing for any customization there. The lowest-level API is where one interacts with the lines, layouts, positions directly, exposing more direct interaction with matplotlib .","title":"Conclusions"},{"location":"api/object-oriented-api/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Object-Oriented API For those who may prefer the object-oriented API of the past, we provide the following class definitions that map directly to the functions. % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 from random import choice import matplotlib.pyplot as plt import networkx as nx import numpy as np import nxviz as nv from nxviz import annotate from nxviz.plots import despine , rescale , respine /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( Example Graph We're going to use an example graph, the erdos-renyi graph, to illustrate. Source code G = nx . erdos_renyi_graph ( n = 71 , p = 0.1 ) for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"group\" ] = choice ([ \"a\" , \"b\" , \"c\" ]) G . nodes [ n ][ \"value\" ] = np . random . exponential () np . random . seed ( 44 ) for u , v , d in G . edges ( data = True ): G . edges [ u , v ][ \"edge_value\" ] = np . random . exponential () API Examples The API from pre-0.7 is mostly preserved as a way to help users who learned the object-oriented API transition over. A key difference here is that instantiating the object and then calling .draw() is no longer necessary. Additionally, annotation logic has been moved out of the class definitions and are now available as part of the annotations submodule. Because the API is no longer being officially supported, these will be officially deprecated in version 1.0. A warning message will show up the first time you try to access any of the objects provided. PRs that try to add an object version of a plot will also be rejected. nv . HivePlot ( G , node_grouping = \"group\" , node_color = \"value\" , node_order = \"value\" , edge_alpha = \"edge_value\" ) from nxviz import annotate annotate . hive_group ( G , group_by = \"group\" , offset = np . pi / 12 ) /home/runner/work/nxviz/nxviz/nxviz/api.py:275: UserWarning: As of nxviz 0.7, the object-oriented API is being deprecated in favour of a functional API. Please consider switching your plotting code! The object-oriented API wrappers remains in place to help you transition over. A few changes between the old and new API exist; please consult the nxviz documentation for more information. When the 1.0 release of nxviz happens, the object-oriented API will be dropped entirely. warnings.warn( nv . CircosPlot ( G , node_grouping = \"group\" , node_color = \"value\" , node_order = \"value\" ) <nxviz.api.CircosPlot at 0x7f7922463670> nv . MatrixPlot ( G , node_grouping = \"group\" , node_color = \"value\" , node_order = \"value\" ) <nxviz.api.MatrixPlot at 0x7f7922463280> nv . ArcPlot ( G , node_grouping = \"group\" , node_color = \"value\" , node_order = \"value\" , edge_color = \"edge_value\" , ) annotate . arc_group ( G , group_by = \"group\" , rotation = 0 )","title":"Object-oriented API"},{"location":"api/object-oriented-api/#object-oriented-api","text":"For those who may prefer the object-oriented API of the past, we provide the following class definitions that map directly to the functions. % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 from random import choice import matplotlib.pyplot as plt import networkx as nx import numpy as np import nxviz as nv from nxviz import annotate from nxviz.plots import despine , rescale , respine /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn(","title":"Object-Oriented API"},{"location":"api/object-oriented-api/#example-graph","text":"We're going to use an example graph, the erdos-renyi graph, to illustrate.","title":"Example Graph"},{"location":"api/object-oriented-api/#source-code","text":"G = nx . erdos_renyi_graph ( n = 71 , p = 0.1 ) for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"group\" ] = choice ([ \"a\" , \"b\" , \"c\" ]) G . nodes [ n ][ \"value\" ] = np . random . exponential () np . random . seed ( 44 ) for u , v , d in G . edges ( data = True ): G . edges [ u , v ][ \"edge_value\" ] = np . random . exponential ()","title":"Source code"},{"location":"api/object-oriented-api/#api-examples","text":"The API from pre-0.7 is mostly preserved as a way to help users who learned the object-oriented API transition over. A key difference here is that instantiating the object and then calling .draw() is no longer necessary. Additionally, annotation logic has been moved out of the class definitions and are now available as part of the annotations submodule. Because the API is no longer being officially supported, these will be officially deprecated in version 1.0. A warning message will show up the first time you try to access any of the objects provided. PRs that try to add an object version of a plot will also be rejected. nv . HivePlot ( G , node_grouping = \"group\" , node_color = \"value\" , node_order = \"value\" , edge_alpha = \"edge_value\" ) from nxviz import annotate annotate . hive_group ( G , group_by = \"group\" , offset = np . pi / 12 ) /home/runner/work/nxviz/nxviz/nxviz/api.py:275: UserWarning: As of nxviz 0.7, the object-oriented API is being deprecated in favour of a functional API. Please consider switching your plotting code! The object-oriented API wrappers remains in place to help you transition over. A few changes between the old and new API exist; please consult the nxviz documentation for more information. When the 1.0 release of nxviz happens, the object-oriented API will be dropped entirely. warnings.warn( nv . CircosPlot ( G , node_grouping = \"group\" , node_color = \"value\" , node_order = \"value\" ) <nxviz.api.CircosPlot at 0x7f7922463670> nv . MatrixPlot ( G , node_grouping = \"group\" , node_color = \"value\" , node_order = \"value\" ) <nxviz.api.MatrixPlot at 0x7f7922463280> nv . ArcPlot ( G , node_grouping = \"group\" , node_color = \"value\" , node_order = \"value\" , edge_color = \"edge_value\" , ) annotate . arc_group ( G , group_by = \"group\" , rotation = 0 )","title":"API Examples"},{"location":"developers/architecture/","text":"Library Architecture nxviz 's architecture, or how the code is organized, follows the logical structure of prioritizing nodes' positioning over edges. As such, there are multiple API layers. We have documentation on how to use each of those API layers, so we won't go through them too closely here. High level At the high level, we provide the following plots in the nxviz main namespace: Graph visualizations with no cloned axes arc : Arc plots circos : Circos plots parallel : Parallel coordinate plots Graph visualizations with cloned axes hive : Hive plots matrix : Matrix plots The intent for this level of API is to provide a single function call that enables users to draw a graph to screen. Intended usage example import nxviz as nv ax = nv . hive ( G , group_by = \"group\" , sort_by = \"value\" , node_color_by = \"value\" ) Medium Level At the medium level API, users interact with node layout and plotting functions in nxviz.nodes as well as edge drawing functions in nxviz.edges . Mostly it provides a way to compose node rendering and edge rendering. Mapping from quantitative or qualitative data is still done by nxviz's built-in default functions, and can't be changed at this level. Intended usage example Here is an example of how one would use the mid-level API. from nxviz import nodes , edges pos = nodes . circos ( G , group_by = \"group\" , sort_by = \"value\" , color_by = \"group\" ) edges . circos ( G , pos , alpha_by = \"edge_value\" ) Low Level At the low level API, nxviz provides users with the maximum amount of control over node and edge styling. Here, instead of passing graph objects into the plotting and layout functions, users interact with node and edge tables. For node plotting, the steps are: Obtain the node table Using the node table, obtain the node positions using a node layout function. Using the node table, obtain node color, transparency, and sizes based on node metadata. Finally, obtain the matplotlib patches, and add them to the plot. For edge plotting, the steps are: Obtain the edge table Using the edge table, obtain the edge color, transparency and line widths based on edge metadata. Finally, obtain the matplotlib patches, and add them to the plot. Intended usage example Here's an example of how one would use the low-level API. from nxviz import lines ax = plt . gca () ##### Part 1: Nodes ##### # 1. Obtain node table nt = utils . node_table ( G ) # 2. Obtain positions using node table. pos = layouts . circos ( nt , group_by = \"group\" , sort_by = \"value\" ) # 3. Obtain node styles node_color = group_colormap ( nt [ \"group\" ]) alpha = nodes . transparency ( nt , alpha_by = None ) size = nodes . node_size ( nt , \"value\" ) # 4. Obtain patches styled correctly and add them to matplotlib axes. patches = nodes . node_glyphs ( nt , pos , node_color = node_color , alpha = alpha , size = size ) for patch in patches : ax . add_patch ( patch ) ##### Part 2: Edges ##### # 1. Obtain edge table et = utils . edge_table ( G ) # 2. Obtain edge styling. edge_color = edges . edge_colors ( et , nt = None , color_by = None , node_color_by = None ) lw = np . sqrt ( et [ \"edge_value\" ]) alpha = edges . transparency ( et , alpha_by = None ) # 3. Obtain edge patches styled and add them to matplotlib axes. patches = lines . circos ( et , pos , edge_color = edge_color , alpha = alpha , lw = lw , aes_kw = { \"fc\" : \"none\" } ) for patch in patches : ax . add_patch ( patch ) Plotting utilities We include some plotting utilities to make composing new plots together a bit easier. These functions are located in the nxviz.plots module. These include functions to rescale matplotlib axes ( plots.rescale() ), and despine and re-spine the axes objects ( plots.despine() and plots.respine() ). Annotations The core node and edge drawing functions can be composed with a variety of annotations onto the axes. These are all located in the nxviz.annotate module. For example, if one wants to add grouping annotations onto a Circos plot, one would use annotate.circos_group . Or if one wants to add in group block diagonals to the Matrix plot, one would call annotate.matrix_block . Visual Encodings The default functions for mapping data to visual properties of node and edges are located in the nxviz.nodes and nxviz.edges modules. Underneath the hood, however, they call on functions in the encodings module. The pattern here is to produce an iterable of colors that correspond to each node and edge, done in a data-driven fashion. Underneath the hood, for code conciseness, we take advantage of the pandas DataFrame and Series APIs. Geometry The nxviz.polcart and nxviz.geometry modules give us convenience functions for calculating (x, y) coordinates from polcar coordinates and doing trigonometric calculations. (These are heavily used in plots with circular layouts, such as the Circos and Hive plots.) Utils The nxviz.utils module is a catch-all for utility functions that don't fall into the aforementioned categories. For example, the node and edge table functions ( utils.node_table(G) and utils.edge_table(G) ), which construct the pandas DataFrame versions of the node set and edge set, are located in there. Because grouping and sorting nodes are intrinsic to constructing rational graph visualizations, the function utils.group_and_sort(nt) is also provided in there. Finally, there are utilities for automatically inferring whether a column of data is categorical, ordinal, or continuous based on data types and ranges. (That is used for identifying colormaps to be used for a particular data.)","title":"Architecture"},{"location":"developers/architecture/#library-architecture","text":"nxviz 's architecture, or how the code is organized, follows the logical structure of prioritizing nodes' positioning over edges. As such, there are multiple API layers. We have documentation on how to use each of those API layers, so we won't go through them too closely here.","title":"Library Architecture"},{"location":"developers/architecture/#high-level","text":"At the high level, we provide the following plots in the nxviz main namespace: Graph visualizations with no cloned axes arc : Arc plots circos : Circos plots parallel : Parallel coordinate plots Graph visualizations with cloned axes hive : Hive plots matrix : Matrix plots The intent for this level of API is to provide a single function call that enables users to draw a graph to screen.","title":"High level"},{"location":"developers/architecture/#intended-usage-example","text":"import nxviz as nv ax = nv . hive ( G , group_by = \"group\" , sort_by = \"value\" , node_color_by = \"value\" )","title":"Intended usage example"},{"location":"developers/architecture/#medium-level","text":"At the medium level API, users interact with node layout and plotting functions in nxviz.nodes as well as edge drawing functions in nxviz.edges . Mostly it provides a way to compose node rendering and edge rendering. Mapping from quantitative or qualitative data is still done by nxviz's built-in default functions, and can't be changed at this level.","title":"Medium Level"},{"location":"developers/architecture/#intended-usage-example_1","text":"Here is an example of how one would use the mid-level API. from nxviz import nodes , edges pos = nodes . circos ( G , group_by = \"group\" , sort_by = \"value\" , color_by = \"group\" ) edges . circos ( G , pos , alpha_by = \"edge_value\" )","title":"Intended usage example"},{"location":"developers/architecture/#low-level","text":"At the low level API, nxviz provides users with the maximum amount of control over node and edge styling. Here, instead of passing graph objects into the plotting and layout functions, users interact with node and edge tables. For node plotting, the steps are: Obtain the node table Using the node table, obtain the node positions using a node layout function. Using the node table, obtain node color, transparency, and sizes based on node metadata. Finally, obtain the matplotlib patches, and add them to the plot. For edge plotting, the steps are: Obtain the edge table Using the edge table, obtain the edge color, transparency and line widths based on edge metadata. Finally, obtain the matplotlib patches, and add them to the plot.","title":"Low Level"},{"location":"developers/architecture/#intended-usage-example_2","text":"Here's an example of how one would use the low-level API. from nxviz import lines ax = plt . gca () ##### Part 1: Nodes ##### # 1. Obtain node table nt = utils . node_table ( G ) # 2. Obtain positions using node table. pos = layouts . circos ( nt , group_by = \"group\" , sort_by = \"value\" ) # 3. Obtain node styles node_color = group_colormap ( nt [ \"group\" ]) alpha = nodes . transparency ( nt , alpha_by = None ) size = nodes . node_size ( nt , \"value\" ) # 4. Obtain patches styled correctly and add them to matplotlib axes. patches = nodes . node_glyphs ( nt , pos , node_color = node_color , alpha = alpha , size = size ) for patch in patches : ax . add_patch ( patch ) ##### Part 2: Edges ##### # 1. Obtain edge table et = utils . edge_table ( G ) # 2. Obtain edge styling. edge_color = edges . edge_colors ( et , nt = None , color_by = None , node_color_by = None ) lw = np . sqrt ( et [ \"edge_value\" ]) alpha = edges . transparency ( et , alpha_by = None ) # 3. Obtain edge patches styled and add them to matplotlib axes. patches = lines . circos ( et , pos , edge_color = edge_color , alpha = alpha , lw = lw , aes_kw = { \"fc\" : \"none\" } ) for patch in patches : ax . add_patch ( patch )","title":"Intended usage example"},{"location":"developers/architecture/#plotting-utilities","text":"We include some plotting utilities to make composing new plots together a bit easier. These functions are located in the nxviz.plots module. These include functions to rescale matplotlib axes ( plots.rescale() ), and despine and re-spine the axes objects ( plots.despine() and plots.respine() ).","title":"Plotting utilities"},{"location":"developers/architecture/#annotations","text":"The core node and edge drawing functions can be composed with a variety of annotations onto the axes. These are all located in the nxviz.annotate module. For example, if one wants to add grouping annotations onto a Circos plot, one would use annotate.circos_group . Or if one wants to add in group block diagonals to the Matrix plot, one would call annotate.matrix_block .","title":"Annotations"},{"location":"developers/architecture/#visual-encodings","text":"The default functions for mapping data to visual properties of node and edges are located in the nxviz.nodes and nxviz.edges modules. Underneath the hood, however, they call on functions in the encodings module. The pattern here is to produce an iterable of colors that correspond to each node and edge, done in a data-driven fashion. Underneath the hood, for code conciseness, we take advantage of the pandas DataFrame and Series APIs.","title":"Visual Encodings"},{"location":"developers/architecture/#geometry","text":"The nxviz.polcart and nxviz.geometry modules give us convenience functions for calculating (x, y) coordinates from polcar coordinates and doing trigonometric calculations. (These are heavily used in plots with circular layouts, such as the Circos and Hive plots.)","title":"Geometry"},{"location":"developers/architecture/#utils","text":"The nxviz.utils module is a catch-all for utility functions that don't fall into the aforementioned categories. For example, the node and edge table functions ( utils.node_table(G) and utils.edge_table(G) ), which construct the pandas DataFrame versions of the node set and edge set, are located in there. Because grouping and sorting nodes are intrinsic to constructing rational graph visualizations, the function utils.group_and_sort(nt) is also provided in there. Finally, there are utilities for automatically inferring whether a column of data is categorical, ordinal, or continuous based on data types and ranges. (That is used for identifying colormaps to be used for a particular data.)","title":"Utils"},{"location":"developers/contributing/","text":"How to contribute Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs Report bugs at https://github.com/ericmjl/nxviz/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. A minimally reproducible example (a.k.a. reprex) to reproduce the bug. Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation nxviz could always use more documentation, whether as part of the official nxviz docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback The best way to send feedback is to file an issue at https://github.com/ericmjl/nxviz/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Because nxviz is currently maintained by volunteers and has no fiscal support, any feature requests will be prioritized according to what maintainers encounter as a need in our day-to-day jobs. Please temper expectations accordingly.","title":"Ways to contribute"},{"location":"developers/contributing/#how-to-contribute","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"How to contribute"},{"location":"developers/contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"developers/contributing/#report-bugs","text":"Report bugs at https://github.com/ericmjl/nxviz/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. A minimally reproducible example (a.k.a. reprex) to reproduce the bug.","title":"Report Bugs"},{"location":"developers/contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"developers/contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"developers/contributing/#write-documentation","text":"nxviz could always use more documentation, whether as part of the official nxviz docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"developers/contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/ericmjl/nxviz/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Because nxviz is currently maintained by volunteers and has no fiscal support, any feature requests will be prioritized according to what maintainers encounter as a need in our day-to-day jobs. Please temper expectations accordingly.","title":"Submit Feedback"},{"location":"developers/devguide/","text":"Development Guide","title":"Development Guide"},{"location":"developers/devguide/#development-guide","text":"","title":"Development Guide"},{"location":"developers/new-plots/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Implementing a new plot We'll show you how to implement a new plot using the nxviz's layered API. As an example, we'll show you how the design process works for the matrix plot. % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 Example graph As always, we'll need an example graph to anchor our notebook. from random import choice import networkx as nx import numpy as np G = nx . erdos_renyi_graph ( n = 20 , p = 0.1 ) for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"group\" ] = choice ([ \"a\" , \"b\" , \"c\" ]) G . nodes [ n ][ \"value\" ] = np . random . exponential () np . random . seed ( 44 ) for u , v , d in G . edges ( data = True ): G . edges [ u , v ][ \"edge_value\" ] = np . random . exponential () Implement node layout We first have to worry about how the nodes are placed. Therefore, we need a node layout function. All node layout functions accept the following arguments: a node table nt , the key to group_by the key to sort_by (optionally) any other relevant keyword arguments With the matrix plot layout, from thinking about how the nodes should be laid out, we will probably arrive at the conclusion that grouping and sorting are technically optional and not intrinsic to the layout. If that's not obvious at first glance, please think about it, you'll probably arrive at the same conclusion! They then return the x, y coordinates to place nodes on. The exact glyphs and their styles are out-of-bounds! Therefore, don't worry about them just yet. from typing import Hashable import pandas as pd from nxviz.utils import group_and_sort # Just the skeleton first! def matrix_layout ( nt : pd . DataFrame , group_by : Hashable = None , sort_by : Hashable = None ): nt = group_and_sort ( nt = nt , group_by = group_by , sort_by = sort_by ) /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( With a matrix plot, our goal is to place nodes along the x- and y-axis. It's a bit like the hive plot with cloned axes. See the code annotations for the logic. # Filling in the x,y positions dictionary. def matrix_layout ( nt : pd . DataFrame , group_by : Hashable = None , sort_by : Hashable = None , axis = \"x\" , ): # Nodes should be grouped and sorted before we begin assigning coordinates. nt = group_and_sort ( node_table = nt , group_by = group_by , sort_by = sort_by ) # We are eventually going to return this pos dictionary. pos = dict () # Loop over each of the rows, and assign x, y coordinates in order of them being grouped and sorted. for i , ( node , data ) in enumerate ( nt . iterrows ()): x = ( i + 1 ) * 2 y = 0 if axis == \"y\" : x , y = y , x pos [ node ] = np . array ([ x , y ]) return pos Now that we have the positions implemented, let's see what they look like. from nxviz import layouts from nxviz.utils import node_table nt = node_table ( G ) pos_x = matrix_layout ( nt , group_by = \"group\" , sort_by = \"value\" ) pos_y = matrix_layout ( nt , group_by = \"group\" , sort_by = \"value\" , axis = \"y\" ) pd . DataFrame ( pos_x ) . T .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 12 2 0 0 4 0 5 6 0 16 8 0 3 10 0 8 12 0 9 14 0 10 16 0 13 18 0 17 20 0 7 22 0 6 24 0 2 26 0 1 28 0 11 30 0 15 32 0 14 34 0 18 36 0 19 38 0 4 40 0 pd . DataFrame ( pos_y ) . T .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 12 0 2 0 0 4 5 0 6 16 0 8 3 0 10 8 0 12 9 0 14 10 0 16 13 0 18 17 0 20 7 0 22 6 0 24 2 0 26 1 0 28 11 0 30 15 0 32 14 0 34 18 0 36 19 0 38 4 0 40 Now, we can worry about the glyphs being drawn to screen. We will follow the logic for the mid-level API. There is a draw function that we can take advantage of to make it happen. from functools import partial from nxviz import nodes matrix = partial ( nodes . draw , layout_func = matrix_layout , group_by = None , sort_by = None ) pos_x = matrix ( G ) pos_y = matrix ( G , layout_kwargs = dict ( axis = \"y\" )) Not bad! We're off to a good start. This looks ugly, but upon inspection, its' because the aspect ratio isn't that good. We can fix this. from nxviz.plots import aspect_equal , despine matrix = partial ( nodes . draw , layout_func = matrix_layout , group_by = None , sort_by = None ) pos_x = matrix ( G ) pos_y = matrix ( G , layout_kwargs = dict ( axis = \"y\" )) aspect_equal () despine () Now that's looking good! We have a square matrix, just as we expected. Drawing edges For edges, we could take advantage of hive plot's lines. That would make the chart look interesting... like one of those arts and crafts tapestries we might have made when we were younger. from nxviz import edges matrix = partial ( nodes . draw , layout_func = matrix_layout , group_by = None , sort_by = None ) pos_x = matrix ( G ) pos_y = matrix ( G , layout_kwargs = dict ( axis = \"y\" )) edges . hive ( G , pos_x , pos_cloned = pos_y , curves = False ) However, the spirit of a matrix plot is to fill in an n-by-n matrix. Thus, we should actually be using a custom implementation of edges that draws in a circle glyph where needed. The matrix \"lines\" function will follow the API of the functions in the nxviz.lines file. Lines are in quotes because we're not technically writing out lines. :) from typing import Dict , Iterable from matplotlib.patches import Circle def matrix_lines ( et , pos , pos_cloned , edge_color : Iterable , alpha : Iterable , lw : Iterable , aes_kw : Dict , ): patches = [] for r , d in et . iterrows (): start = d [ \"source\" ] end = d [ \"target\" ] x_start , y_start = pos_y [ start ] x_end , y_end = pos [ end ] x , y = ( max ( x_start , y_start ), max ( x_end , y_end )) kw = { \"fc\" : edge_color [ r ], \"alpha\" : alpha [ r ], \"radius\" : lw [ r ], \"zorder\" : 10 , } kw . update ( aes_kw ) patch = Circle ( xy = ( x , y ), ** kw ) patches . append ( patch ) return patches matrix_edges = partial ( edges . draw , lines_func = matrix_lines ) import matplotlib.pyplot as plt fig , ax = plt . subplots ( figsize = ( 4 , 4 )) pos_x = matrix ( G , group_by = \"group\" , color_by = \"value\" , sort_by = \"value\" ) pos_y = matrix ( G , group_by = \"group\" , color_by = \"value\" , sort_by = \"value\" , layout_kwargs = dict ( axis = \"y\" ), ) edges . matrix ( G , pos_x , pos_cloned = pos_y , alpha_by = \"edge_value\" ) despine () aspect_equal () Annotations We may wish to annotate the plot with additional information. For example, we might want to annotate the node values. This is doable using the same annotation tools available to us in nxviz. Node color by group from nxviz import annotate fig , ax = plt . subplots ( figsize = ( 4 , 4 )) pos_x = matrix ( G , group_by = \"group\" , color_by = \"group\" , sort_by = \"value\" ) pos_y = matrix ( G , group_by = \"group\" , color_by = \"group\" , sort_by = \"value\" , layout_kwargs = dict ( axis = \"y\" ), ) matrix_edges ( G , pos_x , pos_cloned = pos_y , alpha_by = \"edge_value\" ) # Gives us a colorbar next to the chart. annotate . node_colormapping ( G , color_by = \"group\" ) despine () aspect_equal () Node color by value from nxviz import annotate fig , ax = plt . subplots ( figsize = ( 4 , 4 )) pos_x = matrix ( G , group_by = \"group\" , color_by = \"value\" , sort_by = \"value\" ) pos_y = matrix ( G , group_by = \"group\" , color_by = \"value\" , sort_by = \"value\" , layout_kwargs = dict ( axis = \"y\" ), ) matrix_edges ( G , pos_x , pos_cloned = pos_y , encodings_kwargs = { \"alpha_scale\" : 5 }) # Gives us a colorbar next to the chart. annotate . node_colormapping ( G , color_by = \"value\" ) despine () aspect_equal () Annotating group identity The group identities can also be annotated on the chart itself. Here's how the matrix_group annotation function is implemented. from nxviz.plots import respine def matrix_group ( G , group_by , ax = None , offset =- 3.0 , xrotation = 0 , yrotation = 0 ): if ax is None : ax = plt . gca () nt = node_table ( G ) group_sizes = nt . groupby ( group_by ) . apply ( lambda df : len ( df )) proportions = group_sizes / group_sizes . sum () midpoint = proportions / 2 starting_positions = proportions . cumsum () - proportions label_positions = ( starting_positions + midpoint ) * len ( G ) * 2 label_positions += 1 for label , position in label_positions . to_dict () . items (): # Plot the x-axis labels y = offset x = position ax . annotate ( label , xy = ( x , y ), ha = \"center\" , va = \"center\" , rotation = 0 ) # Plot the y-axis labels x = offset y = position ax . annotate ( label , xy = ( x , y ), ha = \"center\" , va = \"center\" , rotation = 90 ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) pos_x = matrix ( G , group_by = \"group\" , color_by = \"group\" , sort_by = \"value\" ) pos_y = matrix ( G , group_by = \"group\" , color_by = \"group\" , sort_by = \"value\" , layout_kwargs = dict ( axis = \"y\" ), ) matrix_edges ( G , pos_x , pos_cloned = pos_y , alpha_by = \"edge_value\" ) # Gives us a colorbar next to the chart. matrix_group ( G , group_by = \"group\" ) despine () aspect_equal () Annotate matrix blocks We could also annotate the matrix blocks using the exact same logic. Matrix blocks are defined as the blocks of nodes in the same group, so this only applies to graphs for which the nodes can be grouped together. fig , ax = plt . subplots ( figsize = ( 4 , 4 )) pos_x = matrix ( G , group_by = \"group\" , color_by = \"group\" , sort_by = \"value\" ) pos_y = matrix ( G , group_by = \"group\" , color_by = \"group\" , sort_by = \"value\" , layout_kwargs = dict ( axis = \"y\" ), ) matrix_edges ( G , pos_x , pos_cloned = pos_y , alpha_by = \"edge_value\" ) matrix_group ( G , group_by = \"group\" ) respine () aspect_equal () ##### FUNCTION STARTS from matplotlib.patches import Rectangle from nxviz import encodings as aes from nxviz import utils nt = node_table ( G ) group_by = \"group\" color_by = \"group\" def matrix_block ( G , group_by , color_by = None , ax = None ): group_sizes = nt . groupby ( group_by ) . apply ( lambda df : len ( df )) * 2 starting_positions = group_sizes . cumsum () + 1 - group_sizes starting_positions colors = pd . Series ([ \"black\" ] * len ( group_sizes ), index = group_sizes . index ) if color_by : color_data = pd . Series ( group_sizes . index , index = group_sizes . index ) colors = aes . data_color ( color_data , color_data ) # Generate patches first patches = [] for label , position in starting_positions . to_dict () . items (): xy = ( position , position ) width = height = group_sizes [ label ] patch = Rectangle ( xy , width , height , zorder = 0 , alpha = 0.1 , facecolor = colors [ label ] ) patches . append ( patch ) if ax is None : ax = plt . gca () # Then add patches in. for patch in patches : ax . add_patch ( patch ) matrix_block ( G , group_by = group_by , color_by = color_by ) ##### FUNCTION ENDS despine () High level API Of course, in showing you how to implement a matrix plot from scratch, we took the code and shoved it into our high-level API. Here's a few examples of how it's used. import nxviz as nv ax = nv . matrix ( G ) ax = nv . matrix ( G , group_by = \"group\" , node_color_by = \"group\" , edge_alpha_by = \"edge_value\" ) annotate . matrix_block ( G , group_by = \"group\" , color_by = \"group\" )","title":"Developing new plots"},{"location":"developers/new-plots/#implementing-a-new-plot","text":"We'll show you how to implement a new plot using the nxviz's layered API. As an example, we'll show you how the design process works for the matrix plot. % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2","title":"Implementing a new plot"},{"location":"developers/new-plots/#example-graph","text":"As always, we'll need an example graph to anchor our notebook. from random import choice import networkx as nx import numpy as np G = nx . erdos_renyi_graph ( n = 20 , p = 0.1 ) for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"group\" ] = choice ([ \"a\" , \"b\" , \"c\" ]) G . nodes [ n ][ \"value\" ] = np . random . exponential () np . random . seed ( 44 ) for u , v , d in G . edges ( data = True ): G . edges [ u , v ][ \"edge_value\" ] = np . random . exponential ()","title":"Example graph"},{"location":"developers/new-plots/#implement-node-layout","text":"We first have to worry about how the nodes are placed. Therefore, we need a node layout function. All node layout functions accept the following arguments: a node table nt , the key to group_by the key to sort_by (optionally) any other relevant keyword arguments With the matrix plot layout, from thinking about how the nodes should be laid out, we will probably arrive at the conclusion that grouping and sorting are technically optional and not intrinsic to the layout. If that's not obvious at first glance, please think about it, you'll probably arrive at the same conclusion! They then return the x, y coordinates to place nodes on. The exact glyphs and their styles are out-of-bounds! Therefore, don't worry about them just yet. from typing import Hashable import pandas as pd from nxviz.utils import group_and_sort # Just the skeleton first! def matrix_layout ( nt : pd . DataFrame , group_by : Hashable = None , sort_by : Hashable = None ): nt = group_and_sort ( nt = nt , group_by = group_by , sort_by = sort_by ) /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( With a matrix plot, our goal is to place nodes along the x- and y-axis. It's a bit like the hive plot with cloned axes. See the code annotations for the logic. # Filling in the x,y positions dictionary. def matrix_layout ( nt : pd . DataFrame , group_by : Hashable = None , sort_by : Hashable = None , axis = \"x\" , ): # Nodes should be grouped and sorted before we begin assigning coordinates. nt = group_and_sort ( node_table = nt , group_by = group_by , sort_by = sort_by ) # We are eventually going to return this pos dictionary. pos = dict () # Loop over each of the rows, and assign x, y coordinates in order of them being grouped and sorted. for i , ( node , data ) in enumerate ( nt . iterrows ()): x = ( i + 1 ) * 2 y = 0 if axis == \"y\" : x , y = y , x pos [ node ] = np . array ([ x , y ]) return pos Now that we have the positions implemented, let's see what they look like. from nxviz import layouts from nxviz.utils import node_table nt = node_table ( G ) pos_x = matrix_layout ( nt , group_by = \"group\" , sort_by = \"value\" ) pos_y = matrix_layout ( nt , group_by = \"group\" , sort_by = \"value\" , axis = \"y\" ) pd . DataFrame ( pos_x ) . T .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 12 2 0 0 4 0 5 6 0 16 8 0 3 10 0 8 12 0 9 14 0 10 16 0 13 18 0 17 20 0 7 22 0 6 24 0 2 26 0 1 28 0 11 30 0 15 32 0 14 34 0 18 36 0 19 38 0 4 40 0 pd . DataFrame ( pos_y ) . T .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 12 0 2 0 0 4 5 0 6 16 0 8 3 0 10 8 0 12 9 0 14 10 0 16 13 0 18 17 0 20 7 0 22 6 0 24 2 0 26 1 0 28 11 0 30 15 0 32 14 0 34 18 0 36 19 0 38 4 0 40 Now, we can worry about the glyphs being drawn to screen. We will follow the logic for the mid-level API. There is a draw function that we can take advantage of to make it happen. from functools import partial from nxviz import nodes matrix = partial ( nodes . draw , layout_func = matrix_layout , group_by = None , sort_by = None ) pos_x = matrix ( G ) pos_y = matrix ( G , layout_kwargs = dict ( axis = \"y\" )) Not bad! We're off to a good start. This looks ugly, but upon inspection, its' because the aspect ratio isn't that good. We can fix this. from nxviz.plots import aspect_equal , despine matrix = partial ( nodes . draw , layout_func = matrix_layout , group_by = None , sort_by = None ) pos_x = matrix ( G ) pos_y = matrix ( G , layout_kwargs = dict ( axis = \"y\" )) aspect_equal () despine () Now that's looking good! We have a square matrix, just as we expected.","title":"Implement node layout"},{"location":"developers/new-plots/#drawing-edges","text":"For edges, we could take advantage of hive plot's lines. That would make the chart look interesting... like one of those arts and crafts tapestries we might have made when we were younger. from nxviz import edges matrix = partial ( nodes . draw , layout_func = matrix_layout , group_by = None , sort_by = None ) pos_x = matrix ( G ) pos_y = matrix ( G , layout_kwargs = dict ( axis = \"y\" )) edges . hive ( G , pos_x , pos_cloned = pos_y , curves = False ) However, the spirit of a matrix plot is to fill in an n-by-n matrix. Thus, we should actually be using a custom implementation of edges that draws in a circle glyph where needed. The matrix \"lines\" function will follow the API of the functions in the nxviz.lines file. Lines are in quotes because we're not technically writing out lines. :) from typing import Dict , Iterable from matplotlib.patches import Circle def matrix_lines ( et , pos , pos_cloned , edge_color : Iterable , alpha : Iterable , lw : Iterable , aes_kw : Dict , ): patches = [] for r , d in et . iterrows (): start = d [ \"source\" ] end = d [ \"target\" ] x_start , y_start = pos_y [ start ] x_end , y_end = pos [ end ] x , y = ( max ( x_start , y_start ), max ( x_end , y_end )) kw = { \"fc\" : edge_color [ r ], \"alpha\" : alpha [ r ], \"radius\" : lw [ r ], \"zorder\" : 10 , } kw . update ( aes_kw ) patch = Circle ( xy = ( x , y ), ** kw ) patches . append ( patch ) return patches matrix_edges = partial ( edges . draw , lines_func = matrix_lines ) import matplotlib.pyplot as plt fig , ax = plt . subplots ( figsize = ( 4 , 4 )) pos_x = matrix ( G , group_by = \"group\" , color_by = \"value\" , sort_by = \"value\" ) pos_y = matrix ( G , group_by = \"group\" , color_by = \"value\" , sort_by = \"value\" , layout_kwargs = dict ( axis = \"y\" ), ) edges . matrix ( G , pos_x , pos_cloned = pos_y , alpha_by = \"edge_value\" ) despine () aspect_equal ()","title":"Drawing edges"},{"location":"developers/new-plots/#annotations","text":"We may wish to annotate the plot with additional information. For example, we might want to annotate the node values. This is doable using the same annotation tools available to us in nxviz.","title":"Annotations"},{"location":"developers/new-plots/#node-color-by-group","text":"from nxviz import annotate fig , ax = plt . subplots ( figsize = ( 4 , 4 )) pos_x = matrix ( G , group_by = \"group\" , color_by = \"group\" , sort_by = \"value\" ) pos_y = matrix ( G , group_by = \"group\" , color_by = \"group\" , sort_by = \"value\" , layout_kwargs = dict ( axis = \"y\" ), ) matrix_edges ( G , pos_x , pos_cloned = pos_y , alpha_by = \"edge_value\" ) # Gives us a colorbar next to the chart. annotate . node_colormapping ( G , color_by = \"group\" ) despine () aspect_equal ()","title":"Node color by group"},{"location":"developers/new-plots/#node-color-by-value","text":"from nxviz import annotate fig , ax = plt . subplots ( figsize = ( 4 , 4 )) pos_x = matrix ( G , group_by = \"group\" , color_by = \"value\" , sort_by = \"value\" ) pos_y = matrix ( G , group_by = \"group\" , color_by = \"value\" , sort_by = \"value\" , layout_kwargs = dict ( axis = \"y\" ), ) matrix_edges ( G , pos_x , pos_cloned = pos_y , encodings_kwargs = { \"alpha_scale\" : 5 }) # Gives us a colorbar next to the chart. annotate . node_colormapping ( G , color_by = \"value\" ) despine () aspect_equal ()","title":"Node color by value"},{"location":"developers/new-plots/#annotating-group-identity","text":"The group identities can also be annotated on the chart itself. Here's how the matrix_group annotation function is implemented. from nxviz.plots import respine def matrix_group ( G , group_by , ax = None , offset =- 3.0 , xrotation = 0 , yrotation = 0 ): if ax is None : ax = plt . gca () nt = node_table ( G ) group_sizes = nt . groupby ( group_by ) . apply ( lambda df : len ( df )) proportions = group_sizes / group_sizes . sum () midpoint = proportions / 2 starting_positions = proportions . cumsum () - proportions label_positions = ( starting_positions + midpoint ) * len ( G ) * 2 label_positions += 1 for label , position in label_positions . to_dict () . items (): # Plot the x-axis labels y = offset x = position ax . annotate ( label , xy = ( x , y ), ha = \"center\" , va = \"center\" , rotation = 0 ) # Plot the y-axis labels x = offset y = position ax . annotate ( label , xy = ( x , y ), ha = \"center\" , va = \"center\" , rotation = 90 ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) pos_x = matrix ( G , group_by = \"group\" , color_by = \"group\" , sort_by = \"value\" ) pos_y = matrix ( G , group_by = \"group\" , color_by = \"group\" , sort_by = \"value\" , layout_kwargs = dict ( axis = \"y\" ), ) matrix_edges ( G , pos_x , pos_cloned = pos_y , alpha_by = \"edge_value\" ) # Gives us a colorbar next to the chart. matrix_group ( G , group_by = \"group\" ) despine () aspect_equal ()","title":"Annotating group identity"},{"location":"developers/new-plots/#annotate-matrix-blocks","text":"We could also annotate the matrix blocks using the exact same logic. Matrix blocks are defined as the blocks of nodes in the same group, so this only applies to graphs for which the nodes can be grouped together. fig , ax = plt . subplots ( figsize = ( 4 , 4 )) pos_x = matrix ( G , group_by = \"group\" , color_by = \"group\" , sort_by = \"value\" ) pos_y = matrix ( G , group_by = \"group\" , color_by = \"group\" , sort_by = \"value\" , layout_kwargs = dict ( axis = \"y\" ), ) matrix_edges ( G , pos_x , pos_cloned = pos_y , alpha_by = \"edge_value\" ) matrix_group ( G , group_by = \"group\" ) respine () aspect_equal () ##### FUNCTION STARTS from matplotlib.patches import Rectangle from nxviz import encodings as aes from nxviz import utils nt = node_table ( G ) group_by = \"group\" color_by = \"group\" def matrix_block ( G , group_by , color_by = None , ax = None ): group_sizes = nt . groupby ( group_by ) . apply ( lambda df : len ( df )) * 2 starting_positions = group_sizes . cumsum () + 1 - group_sizes starting_positions colors = pd . Series ([ \"black\" ] * len ( group_sizes ), index = group_sizes . index ) if color_by : color_data = pd . Series ( group_sizes . index , index = group_sizes . index ) colors = aes . data_color ( color_data , color_data ) # Generate patches first patches = [] for label , position in starting_positions . to_dict () . items (): xy = ( position , position ) width = height = group_sizes [ label ] patch = Rectangle ( xy , width , height , zorder = 0 , alpha = 0.1 , facecolor = colors [ label ] ) patches . append ( patch ) if ax is None : ax = plt . gca () # Then add patches in. for patch in patches : ax . add_patch ( patch ) matrix_block ( G , group_by = group_by , color_by = color_by ) ##### FUNCTION ENDS despine ()","title":"Annotate matrix blocks"},{"location":"developers/new-plots/#high-level-api","text":"Of course, in showing you how to implement a matrix plot from scratch, we took the code and shoved it into our high-level API. Here's a few examples of how it's used. import nxviz as nv ax = nv . matrix ( G ) ax = nv . matrix ( G , group_by = \"group\" , node_color_by = \"group\" , edge_alpha_by = \"edge_value\" ) annotate . matrix_block ( G , group_by = \"group\" , color_by = \"group\" )","title":"High level API"},{"location":"examples/geo/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Geo Plot In this notebook, we will see how to create geographic graph visualizations using the mid-level and high-level APIs. % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 import matplotlib.pyplot as plt import networkx as nx import nxviz as nv from nxviz import edges , layouts , nodes , plots , utils , annotate from pyprojroot import here /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( G = nx . read_gpickle ( here () / \"docs/examples/divvy.pkl\" ) G_new = G . copy () for n1 , n2 , d in G . edges ( data = True ): if d [ \"count\" ] < 150 : G_new . remove_edge ( n1 , n2 ) Mid-level API nt = utils . node_table ( G_new ) pos = nodes . draw ( G_new , layout_func = layouts . geo , group_by = None , sort_by = None , color_by = \"dpcapacity\" , encodings_kwargs = { \"size_scale\" : 0.0015 }, ) edges . line ( G_new , pos ) annotate . node_colormapping ( G_new , color_by = \"dpcapacity\" ) plots . rescale ( G ) plots . aspect_equal () plots . despine () High-level API from nxviz import annotate nv . geo ( G_new , node_color_by = \"dpcapacity\" ) annotate . node_colormapping ( G_new , color_by = \"dpcapacity\" )","title":"Geo Plot"},{"location":"examples/geo/#geo-plot","text":"In this notebook, we will see how to create geographic graph visualizations using the mid-level and high-level APIs. % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 import matplotlib.pyplot as plt import networkx as nx import nxviz as nv from nxviz import edges , layouts , nodes , plots , utils , annotate from pyprojroot import here /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( G = nx . read_gpickle ( here () / \"docs/examples/divvy.pkl\" ) G_new = G . copy () for n1 , n2 , d in G . edges ( data = True ): if d [ \"count\" ] < 150 : G_new . remove_edge ( n1 , n2 )","title":"Geo Plot"},{"location":"examples/geo/#mid-level-api","text":"nt = utils . node_table ( G_new ) pos = nodes . draw ( G_new , layout_func = layouts . geo , group_by = None , sort_by = None , color_by = \"dpcapacity\" , encodings_kwargs = { \"size_scale\" : 0.0015 }, ) edges . line ( G_new , pos ) annotate . node_colormapping ( G_new , color_by = \"dpcapacity\" ) plots . rescale ( G ) plots . aspect_equal () plots . despine ()","title":"Mid-level API"},{"location":"examples/geo/#high-level-api","text":"from nxviz import annotate nv . geo ( G_new , node_color_by = \"dpcapacity\" ) annotate . node_colormapping ( G_new , color_by = \"dpcapacity\" )","title":"High-level API"},{"location":"examples/matrix/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Matrix Plot Here is an example of how to create a matrix plot. % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 import matplotlib.pyplot as plt import networkx as nx import numpy.random as npr import nxviz as nv /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( G = nx . lollipop_graph ( m = 10 , n = 4 ) for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"degree\" ] = nx . degree ( G , n ) ax = nv . matrix ( G , sort_by = \"degree\" , node_color_by = \"degree\" ) nx . draw ( G )","title":"Matrix Plot"},{"location":"examples/matrix/#matrix-plot","text":"Here is an example of how to create a matrix plot. % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 import matplotlib.pyplot as plt import networkx as nx import numpy.random as npr import nxviz as nv /home/runner/work/nxviz/nxviz/nxviz/__init__.py:18: UserWarning: nxviz has a new API! Version 0.7.2 onwards, the old class-based API is being deprecated in favour of a new API focused on advancing a grammar of network graphics. If your plotting code depends on the old API, please consider pinning nxviz at version 0.7.2, as the new API will break your old code. To check out the new API, please head over to the docs at https://ericmjl.github.io/nxviz/ to learn more. We hope you enjoy using it! (This deprecation message will go away in version 1.0.) warnings.warn( G = nx . lollipop_graph ( m = 10 , n = 4 ) for n , d in G . nodes ( data = True ): G . nodes [ n ][ \"degree\" ] = nx . degree ( G , n ) ax = nv . matrix ( G , sort_by = \"degree\" , node_color_by = \"degree\" ) nx . draw ( G )","title":"Matrix Plot"}]}